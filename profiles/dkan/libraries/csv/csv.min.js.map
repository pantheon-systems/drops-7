{"version":3,"sources":["webpack:///csv.min.js","webpack:///webpack/bootstrap a8ddef3ddbeace83784e","webpack:///./csv.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","CSV","my","chomp","s","lineterminator","charAt","length","substring","__type__","Deferred","jQuery","_","fetch","dataset","dfd","file","reader","FileReader","encoding","onload","e","out","extractFields","parse","target","result","useMemoryStore","metadata","filename","name","resolve","onerror","reject","error","message","code","readAsText","data","url","get","done","fail","req","status","statusText","request","promise","rows","noFields","noHeaderRow","fields","records","slice","normalizeDialectOptions","options","delimiter","doublequote","quotechar","skipinitialspace","skipinitialrows","key","trim","toLowerCase","dialect","normalizeLineTerminator","i","processField","cur","inQuote","fieldQuoted","field","row","rxIsInt","test","parseInt","rxIsFloat","parseFloat","push","csvString","replace","objectToArray","dataToSerialize","a","fieldNames","ii","tmp","record","jj","serialize","Array","j","rxNeedsQuoting","toString","String","prototype","recline","Backend"],"mappings":"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","file":"csv.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\tvar CSV = {};\n\t\n\t// Note that provision of jQuery is optional (it is **only** needed if you use fetch on a remote file)\n\t(function(my) {\n\t  \"use strict\";\n\t  my.__type__ = 'csv';\n\t\n\t  // use either jQuery or Underscore Deferred depending on what is available\n\t  var Deferred = (typeof jQuery !== \"undefined\" && jQuery.Deferred) || _.Deferred;\n\t\n\t  my.fetch = function(dataset) {\n\t    var dfd = new Deferred();\n\t    if (dataset.file) {\n\t      var reader = new FileReader();\n\t      var encoding = dataset.encoding || 'UTF-8';\n\t      reader.onload = function(e) {\n\t        var out = my.extractFields(my.parse(e.target.result, dataset), dataset);\n\t        out.useMemoryStore = true;\n\t        out.metadata = {\n\t          filename: dataset.file.name\n\t        }\n\t        dfd.resolve(out);\n\t      };\n\t      reader.onerror = function (e) {\n\t        dfd.reject({error: {message: 'Failed to load file. Code: ' + e.target.error.code }});\n\t      };\n\t      reader.readAsText(dataset.file, encoding);\n\t    } else if (dataset.data) {\n\t      var out = my.extractFields(my.parse(dataset.data, dataset), dataset);\n\t      out.useMemoryStore = true;\n\t      dfd.resolve(out);\n\t    } else if (dataset.url) {\n\t      jQuery.get(dataset.url).done(function(data) {\n\t        var out = my.extractFields(my.parse(data, dataset), dataset);\n\t        out.useMemoryStore = true;\n\t        dfd.resolve(out);\n\t      }).fail(function(req, status){\n\t        dfd.reject({error: {message: 'Failed to load file. ' + req.statusText + '. Code: ' + req.status, request: req}});\n\t      });\n\t    }\n\t    return dfd.promise();\n\t  };\n\t\n\t  // Convert array of rows in { records: [ ...] , fields: [ ... ] }\n\t  // @param {Boolean} noHeaderRow If true assume that first row is not a header (i.e. list of fields but is data.\n\t  my.extractFields = function(rows, noFields) {\n\t    if (noFields.noHeaderRow !== true && rows.length > 0) {\n\t      return {\n\t        fields: rows[0],\n\t        records: rows.slice(1)\n\t      }\n\t    } else {\n\t      return {\n\t        records: rows\n\t      }\n\t    }\n\t  };\n\t\n\t  my.normalizeDialectOptions = function(options) {\n\t    // note lower case compared to CSV DDF\n\t    var out = {\n\t      delimiter: ',',\n\t      doublequote: true,\n\t      lineterminator: '\\n',\n\t      quotechar: '\"',\n\t      skipinitialspace: true,\n\t      skipinitialrows: 0\n\t    };\n\t    for (var key in options) {\n\t      if (key === 'trim') {\n\t        out['skipinitialspace'] = options.trim;\n\t      } else {\n\t        out[key.toLowerCase()] = options[key];\n\t      }\n\t    }\n\t    return out;\n\t  };\n\t\n\t  // ## parse\n\t  //\n\t  // For docs see the README\n\t  //\n\t  // Heavily based on uselesscode's JS CSV parser (MIT Licensed):\n\t  // http://www.uselesscode.org/javascript/csv/\n\t  my.parse= function(s, dialect) {\n\t\n\t    // When line terminator is not provided then we try to guess it\n\t    // and normalize it across the file.\n\t    if(!dialect || (dialect && !dialect.lineterminator)) {\n\t      s = my.normalizeLineTerminator(s, dialect);\n\t    }\n\t\n\t    // Get rid of any trailing \\n\n\t    var options = my.normalizeDialectOptions(dialect);\n\t    s = chomp(s, options.lineterminator);\n\t\n\t    var cur = '', // The character we are currently processing.\n\t      inQuote = false,\n\t      fieldQuoted = false,\n\t      field = '', // Buffer for building up the current field\n\t      row = [],\n\t      out = [],\n\t      i,\n\t      processField;\n\t\n\t    processField = function (field) {\n\t      if (fieldQuoted !== true) {\n\t        // If field is empty set to null\n\t        if (field === '') {\n\t          field = null;\n\t        // If the field was not quoted and we are trimming fields, trim it\n\t        } else if (options.skipinitialspace === true) {\n\t          field = trim(field);\n\t        }\n\t\n\t        // Convert unquoted numbers to their appropriate types\n\t        if (rxIsInt.test(field)) {\n\t          field = parseInt(field, 10);\n\t        } else if (rxIsFloat.test(field)) {\n\t          field = parseFloat(field, 10);\n\t        }\n\t      }\n\t      return field;\n\t    };\n\t\n\t    for (i = 0; i < s.length; i += 1) {\n\t      cur = s.charAt(i);\n\t\n\t      // If we are at a EOF or EOR\n\t      if (inQuote === false && (cur === options.delimiter || cur === options.lineterminator)) {\n\t        field = processField(field);\n\t        // Add the current field to the current row\n\t        row.push(field);\n\t        // If this is EOR append row to output and flush row\n\t        if (cur === options.lineterminator) {\n\t          out.push(row);\n\t          row = [];\n\t        }\n\t        // Flush the field buffer\n\t        field = '';\n\t        fieldQuoted = false;\n\t      } else {\n\t        // If it's not a quotechar, add it to the field buffer\n\t        if (cur !== options.quotechar) {\n\t          field += cur;\n\t        } else {\n\t          if (!inQuote) {\n\t            // We are not in a quote, start a quote\n\t            inQuote = true;\n\t            fieldQuoted = true;\n\t          } else {\n\t            // Next char is quotechar, this is an escaped quotechar\n\t            if (s.charAt(i + 1) === options.quotechar) {\n\t              field += options.quotechar;\n\t              // Skip the next char\n\t              i += 1;\n\t            } else {\n\t              // It's not escaping, so end quote\n\t              inQuote = false;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // Add the last field\n\t    field = processField(field);\n\t    row.push(field);\n\t    out.push(row);\n\t\n\t    // Expose the ability to discard initial rows\n\t    if (options.skipinitialrows) out = out.slice(options.skipinitialrows);\n\t\n\t    return out;\n\t  };\n\t\n\t  my.normalizeLineTerminator = function(csvString, dialect){\n\t    dialect = dialect || {};\n\t\n\t    // Try to guess line terminator if it's not provided.\n\t    if (!dialect.lineterminator) {\n\t      return csvString.replace(/(\\r\\n|\\n|\\r)/gm, '\\n');\n\t    }\n\t    // if not return the string untouched.\n\t    return csvString;\n\t  };\n\t\n\t  my.objectToArray = function(dataToSerialize) {\n\t    var a = [];\n\t    var fieldNames = [];\n\t    for (var ii=0; ii<dataToSerialize.fields.length; ii++) {\n\t      fieldNames.push(dataToSerialize.fields[ii].id);\n\t    }\n\t    a.push(fieldNames);\n\t    for (var ii=0; ii<dataToSerialize.records.length; ii++) {\n\t      var tmp = [];\n\t      var record = dataToSerialize.records[ii];\n\t      for (var jj=0; jj<fieldNames.length; jj++) {\n\t        tmp.push(record[fieldNames[jj]]);\n\t      }\n\t      a.push(tmp);\n\t    }\n\t    return a;\n\t  }\n\t\n\t  // ## serialize\n\t  //\n\t  // See README for docs\n\t  //\n\t  // Heavily based on uselesscode's JS CSV serializer (MIT Licensed):\n\t  // http://www.uselesscode.org/javascript/csv/\n\t  my.serialize = function(dataToSerialize, dialect) {\n\t    var a = null;\n\t    if (dataToSerialize instanceof Array) {\n\t      a = dataToSerialize;\n\t    } else {\n\t      a = my.objectToArray(dataToSerialize);\n\t    }\n\t    var options = my.normalizeDialectOptions(dialect);\n\t\n\t    var cur = '', // The character we are currently processing.\n\t      field = '', // Buffer for building up the current field\n\t      row = '',\n\t      out = '',\n\t      i,\n\t      j,\n\t      processField;\n\t\n\t    processField = function (field) {\n\t      if (field === null) {\n\t        // If field is null set to empty string\n\t        field = '';\n\t      } else if (typeof field === \"string\" && rxNeedsQuoting.test(field)) {\n\t        if (options.doublequote) {\n\t          field = field.replace(/\"/g, '\"\"');\n\t        }\n\t        // Convert string to delimited string\n\t        field = options.quotechar + field + options.quotechar;\n\t      } else if (typeof field === \"number\") {\n\t        // Convert number to string\n\t        field = field.toString(10);\n\t      }\n\t\n\t      return field;\n\t    };\n\t\n\t    for (i = 0; i < a.length; i += 1) {\n\t      cur = a[i];\n\t\n\t      for (j = 0; j < cur.length; j += 1) {\n\t        field = processField(cur[j]);\n\t        // If this is EOR append row to output and flush row\n\t        if (j === (cur.length - 1)) {\n\t          row += field;\n\t          out += row + options.lineterminator;\n\t          row = '';\n\t        } else {\n\t          // Add the current field to the current row\n\t          row += field + options.delimiter;\n\t        }\n\t        // Flush the field buffer\n\t        field = '';\n\t      }\n\t    }\n\t\n\t    return out;\n\t  };\n\t\n\t  var rxIsInt = /^\\d+$/,\n\t    rxIsFloat = /^\\d*\\.\\d+$|^\\d+\\.\\d*$/,\n\t    // If a string has leading or trailing space,\n\t    // contains a comma double quote or a newline\n\t    // it needs to be quoted in CSV output\n\t    rxNeedsQuoting = /^\\s|\\s$|,|\"|\\n/,\n\t    trim = (function () {\n\t      // Fx 3.1 has a native trim function, it's about 10x faster, use it if it exists\n\t      if (String.prototype.trim) {\n\t        return function (s) {\n\t          return s.trim();\n\t        };\n\t      } else {\n\t        return function (s) {\n\t          return s.replace(/^\\s*/, '').replace(/\\s*$/, '');\n\t        };\n\t      }\n\t    }());\n\t\n\t  function chomp(s, lineterminator) {\n\t    if (s.charAt(s.length - lineterminator.length) !== lineterminator) {\n\t      // Does not end with \\n, just return string\n\t      return s;\n\t    } else {\n\t      // Remove the \\n\n\t      return s.substring(0, s.length - lineterminator.length);\n\t    }\n\t  }\n\t}(CSV));\n\t\n\t\n\t// backwards compatability for use in Recline\n\tvar recline = recline || {};\n\trecline.Backend = recline.Backend || {};\n\trecline.Backend.CSV = CSV;\n\t\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** csv.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a8ddef3ddbeace83784e\n **/","var CSV = {};\n\n// Note that provision of jQuery is optional (it is **only** needed if you use fetch on a remote file)\n(function(my) {\n  \"use strict\";\n  my.__type__ = 'csv';\n\n  // use either jQuery or Underscore Deferred depending on what is available\n  var Deferred = (typeof jQuery !== \"undefined\" && jQuery.Deferred) || _.Deferred;\n\n  my.fetch = function(dataset) {\n    var dfd = new Deferred();\n    if (dataset.file) {\n      var reader = new FileReader();\n      var encoding = dataset.encoding || 'UTF-8';\n      reader.onload = function(e) {\n        var out = my.extractFields(my.parse(e.target.result, dataset), dataset);\n        out.useMemoryStore = true;\n        out.metadata = {\n          filename: dataset.file.name\n        }\n        dfd.resolve(out);\n      };\n      reader.onerror = function (e) {\n        dfd.reject({error: {message: 'Failed to load file. Code: ' + e.target.error.code }});\n      };\n      reader.readAsText(dataset.file, encoding);\n    } else if (dataset.data) {\n      var out = my.extractFields(my.parse(dataset.data, dataset), dataset);\n      out.useMemoryStore = true;\n      dfd.resolve(out);\n    } else if (dataset.url) {\n      jQuery.get(dataset.url).done(function(data) {\n        var out = my.extractFields(my.parse(data, dataset), dataset);\n        out.useMemoryStore = true;\n        dfd.resolve(out);\n      }).fail(function(req, status){\n        dfd.reject({error: {message: 'Failed to load file. ' + req.statusText + '. Code: ' + req.status, request: req}});\n      });\n    }\n    return dfd.promise();\n  };\n\n  // Convert array of rows in { records: [ ...] , fields: [ ... ] }\n  // @param {Boolean} noHeaderRow If true assume that first row is not a header (i.e. list of fields but is data.\n  my.extractFields = function(rows, noFields) {\n    if (noFields.noHeaderRow !== true && rows.length > 0) {\n      return {\n        fields: rows[0],\n        records: rows.slice(1)\n      }\n    } else {\n      return {\n        records: rows\n      }\n    }\n  };\n\n  my.normalizeDialectOptions = function(options) {\n    // note lower case compared to CSV DDF\n    var out = {\n      delimiter: ',',\n      doublequote: true,\n      lineterminator: '\\n',\n      quotechar: '\"',\n      skipinitialspace: true,\n      skipinitialrows: 0\n    };\n    for (var key in options) {\n      if (key === 'trim') {\n        out['skipinitialspace'] = options.trim;\n      } else {\n        out[key.toLowerCase()] = options[key];\n      }\n    }\n    return out;\n  };\n\n  // ## parse\n  //\n  // For docs see the README\n  //\n  // Heavily based on uselesscode's JS CSV parser (MIT Licensed):\n  // http://www.uselesscode.org/javascript/csv/\n  my.parse= function(s, dialect) {\n\n    // When line terminator is not provided then we try to guess it\n    // and normalize it across the file.\n    if(!dialect || (dialect && !dialect.lineterminator)) {\n      s = my.normalizeLineTerminator(s, dialect);\n    }\n\n    // Get rid of any trailing \\n\n    var options = my.normalizeDialectOptions(dialect);\n    s = chomp(s, options.lineterminator);\n\n    var cur = '', // The character we are currently processing.\n      inQuote = false,\n      fieldQuoted = false,\n      field = '', // Buffer for building up the current field\n      row = [],\n      out = [],\n      i,\n      processField;\n\n    processField = function (field) {\n      if (fieldQuoted !== true) {\n        // If field is empty set to null\n        if (field === '') {\n          field = null;\n        // If the field was not quoted and we are trimming fields, trim it\n        } else if (options.skipinitialspace === true) {\n          field = trim(field);\n        }\n\n        // Convert unquoted numbers to their appropriate types\n        if (rxIsInt.test(field)) {\n          field = parseInt(field, 10);\n        } else if (rxIsFloat.test(field)) {\n          field = parseFloat(field, 10);\n        }\n      }\n      return field;\n    };\n\n    for (i = 0; i < s.length; i += 1) {\n      cur = s.charAt(i);\n\n      // If we are at a EOF or EOR\n      if (inQuote === false && (cur === options.delimiter || cur === options.lineterminator)) {\n        field = processField(field);\n        // Add the current field to the current row\n        row.push(field);\n        // If this is EOR append row to output and flush row\n        if (cur === options.lineterminator) {\n          out.push(row);\n          row = [];\n        }\n        // Flush the field buffer\n        field = '';\n        fieldQuoted = false;\n      } else {\n        // If it's not a quotechar, add it to the field buffer\n        if (cur !== options.quotechar) {\n          field += cur;\n        } else {\n          if (!inQuote) {\n            // We are not in a quote, start a quote\n            inQuote = true;\n            fieldQuoted = true;\n          } else {\n            // Next char is quotechar, this is an escaped quotechar\n            if (s.charAt(i + 1) === options.quotechar) {\n              field += options.quotechar;\n              // Skip the next char\n              i += 1;\n            } else {\n              // It's not escaping, so end quote\n              inQuote = false;\n            }\n          }\n        }\n      }\n    }\n\n    // Add the last field\n    field = processField(field);\n    row.push(field);\n    out.push(row);\n\n    // Expose the ability to discard initial rows\n    if (options.skipinitialrows) out = out.slice(options.skipinitialrows);\n\n    return out;\n  };\n\n  my.normalizeLineTerminator = function(csvString, dialect){\n    dialect = dialect || {};\n\n    // Try to guess line terminator if it's not provided.\n    if (!dialect.lineterminator) {\n      return csvString.replace(/(\\r\\n|\\n|\\r)/gm, '\\n');\n    }\n    // if not return the string untouched.\n    return csvString;\n  };\n\n  my.objectToArray = function(dataToSerialize) {\n    var a = [];\n    var fieldNames = [];\n    for (var ii=0; ii<dataToSerialize.fields.length; ii++) {\n      fieldNames.push(dataToSerialize.fields[ii].id);\n    }\n    a.push(fieldNames);\n    for (var ii=0; ii<dataToSerialize.records.length; ii++) {\n      var tmp = [];\n      var record = dataToSerialize.records[ii];\n      for (var jj=0; jj<fieldNames.length; jj++) {\n        tmp.push(record[fieldNames[jj]]);\n      }\n      a.push(tmp);\n    }\n    return a;\n  }\n\n  // ## serialize\n  //\n  // See README for docs\n  //\n  // Heavily based on uselesscode's JS CSV serializer (MIT Licensed):\n  // http://www.uselesscode.org/javascript/csv/\n  my.serialize = function(dataToSerialize, dialect) {\n    var a = null;\n    if (dataToSerialize instanceof Array) {\n      a = dataToSerialize;\n    } else {\n      a = my.objectToArray(dataToSerialize);\n    }\n    var options = my.normalizeDialectOptions(dialect);\n\n    var cur = '', // The character we are currently processing.\n      field = '', // Buffer for building up the current field\n      row = '',\n      out = '',\n      i,\n      j,\n      processField;\n\n    processField = function (field) {\n      if (field === null) {\n        // If field is null set to empty string\n        field = '';\n      } else if (typeof field === \"string\" && rxNeedsQuoting.test(field)) {\n        if (options.doublequote) {\n          field = field.replace(/\"/g, '\"\"');\n        }\n        // Convert string to delimited string\n        field = options.quotechar + field + options.quotechar;\n      } else if (typeof field === \"number\") {\n        // Convert number to string\n        field = field.toString(10);\n      }\n\n      return field;\n    };\n\n    for (i = 0; i < a.length; i += 1) {\n      cur = a[i];\n\n      for (j = 0; j < cur.length; j += 1) {\n        field = processField(cur[j]);\n        // If this is EOR append row to output and flush row\n        if (j === (cur.length - 1)) {\n          row += field;\n          out += row + options.lineterminator;\n          row = '';\n        } else {\n          // Add the current field to the current row\n          row += field + options.delimiter;\n        }\n        // Flush the field buffer\n        field = '';\n      }\n    }\n\n    return out;\n  };\n\n  var rxIsInt = /^\\d+$/,\n    rxIsFloat = /^\\d*\\.\\d+$|^\\d+\\.\\d*$/,\n    // If a string has leading or trailing space,\n    // contains a comma double quote or a newline\n    // it needs to be quoted in CSV output\n    rxNeedsQuoting = /^\\s|\\s$|,|\"|\\n/,\n    trim = (function () {\n      // Fx 3.1 has a native trim function, it's about 10x faster, use it if it exists\n      if (String.prototype.trim) {\n        return function (s) {\n          return s.trim();\n        };\n      } else {\n        return function (s) {\n          return s.replace(/^\\s*/, '').replace(/\\s*$/, '');\n        };\n      }\n    }());\n\n  function chomp(s, lineterminator) {\n    if (s.charAt(s.length - lineterminator.length) !== lineterminator) {\n      // Does not end with \\n, just return string\n      return s;\n    } else {\n      // Remove the \\n\n      return s.substring(0, s.length - lineterminator.length);\n    }\n  }\n}(CSV));\n\n\n// backwards compatability for use in Recline\nvar recline = recline || {};\nrecline.Backend = recline.Backend || {};\nrecline.Backend.CSV = CSV;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./csv.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}