<?php

/**
 * @file
 * Module file for the features module, which enables the capture and
 * management of features in Drupal. A feature is a collection of Drupal
 * entities which taken together satisfy a certain use-case.
 */

define('FEATURES_API', '2');

define('FEATURES_MODULE_ENABLED', 1);
define('FEATURES_MODULE_DISABLED', 0);
define('FEATURES_MODULE_MISSING', -1);
define('FEATURES_MODULE_CONFLICT', 2);

define('FEATURES_REBUILDABLE', -1);
define('FEATURES_DEFAULT', 0);
define('FEATURES_OVERRIDDEN', 1);
define('FEATURES_NEEDS_REVIEW', 2);
define('FEATURES_REBUILDING', 3);
define('FEATURES_CONFLICT', 4);
define('FEATURES_DISABLED', 5);
define('FEATURES_CHECKING', 6);
define('FEATURES_ALTER_TYPE_NORMAL', 'normal');
define('FEATURES_ALTER_TYPE_INLINE', 'inline');
define('FEATURES_ALTER_TYPE_NONE', 'none');

// Duration of rebuild semaphore: 10 minutes.
define('FEATURES_SEMAPHORE_TIMEOUT', 10 * 60);

/**
 * Components with this 'default_file' flag will have exports written to the
 * common defaults file 'MODULENAME.features.inc'. This is the default
 * behavior.
 */
define('FEATURES_DEFAULTS_INCLUDED_COMMON', 0);

/**
 * Components with this 'default_file' flag will have exports written to a
 * defaults based on the component name like 'MODULENAME.features.COMPONENT-NAME.inc'.
 * Any callers to this component's defaults hook must call
 * features_include_defaults('component') in order to include this file.
 */
define('FEATURES_DEFAULTS_INCLUDED', 1);

/**
 * Components with this 'default_file' flag must specify a filename for their
 * exports. Additionally a stub will NOT be written to 'MODULENAME.features.inc'
 * allowing the file to be included directly by the implementing module.
 */
define('FEATURES_DEFAULTS_CUSTOM', 2);

/**
 * Components with this 'duplicates' flag may not have multiple features provide the
 * same component key in their info files. This is the default behavior.
 */
define('FEATURES_DUPLICATES_CONFLICT', 0);

/**
 * Components with this 'duplicates' flag are allowed to have multiple features
 * provide the same component key in their info files.
 */
define('FEATURES_DUPLICATES_ALLOWED', 1);

/**
 * The default destination path for features exported via the UI.
 */
define('FEATURES_DEFAULT_EXPORT_PATH', 'sites/all/modules');

/**
 * Implements hook_menu().
 */
function features_menu() {
  $items = array();
  $items['admin/structure/features'] = array(
    'title' => 'Features',
    'description' => 'Manage features.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('features_admin_form'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'features.admin.inc',
  );
  $items['admin/structure/features/cleanup'] = array(
    'title' => 'Cleanup',
    'description' => 'Clear cache after enabling/disabling a feature.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('features_cleanup_form', 4),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
    'weight' => 1,
  );
  $items['admin/structure/features/manage'] = array(
    'title' => 'Manage',
    'description' => 'Enable and disable features.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('features_admin_form'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'features.admin.inc',
  );
  $items['admin/structure/features/create'] = array(
    'title' => 'Create feature',
    'description' => 'Create a new feature.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('features_export_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_LOCAL_TASK,
    'file' => "features.admin.inc",
    'weight' => 10,
  );
  $items['admin/structure/features/settings'] = array(
    'title' => 'Settings',
    'description' => 'Adjust settings for using features module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('features_settings_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_LOCAL_TASK,
    'file' => "features.admin.inc",
    'weight' => 11,
  );


  $items['admin/structure/features/%feature'] = array(
    'title callback' => 'features_get_feature_title',
    'title arguments' => array(3),
    'description' => 'Display components of a feature.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('features_admin_components', 3),
    'load arguments' => array(3, TRUE),
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
  );
  $items['admin/structure/features/%feature/view'] = array(
    'title' => 'View',
    'description' => 'Display components of a feature.',
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/features/%feature/recreate'] = array(
    'title' => 'Recreate',
    'description' => 'Recreate an existing feature.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('features_export_form', 3),
    'load arguments' => array(3, TRUE),
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_LOCAL_TASK,
    'file' => "features.admin.inc",
    'weight' => 11,
  );
  if (module_exists('diff')) {
    $items['admin/structure/features/%feature/diff'] = array(
      'title' => 'Review overrides',
      'description' => 'Compare default and current feature.',
      'page callback' => 'features_feature_diff',
      'page arguments' => array(3, 5),
      'load arguments' => array(3, TRUE),
      'access callback' => 'features_access_override_actions',
      'access arguments' => array(3),
      'type' => MENU_LOCAL_TASK,
      'file' => 'features.admin.inc',
    );
  }

  $items['admin/structure/features/%feature/lock'] = array(
    'title' => 'Lock',
    'description' => 'Lock a feature or components.',
    'page callback' => 'features_admin_lock',
    'page arguments' => array(3, 5, 6),
    'load arguments' => array(3, TRUE, TRUE),
    'access arguments' => array('administer features'),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
  );
  $items['admin/structure/features/%feature/status'] = array(
    'title' => 'Status',
    'description' => 'Javascript status call back.',
    'page callback' => 'features_feature_status',
    'page arguments' => array(3),
    'load arguments' => array(3, TRUE),
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
  );
  $items['features/autocomplete/packages'] = array(
    'page callback' => 'features_autocomplete_packages',
    'access arguments' => array('administer features'),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
  );
  $items['features/ajaxcallback/%'] = array(
    'title callback' => 'features_get_feature_components',
    'description' => 'Return components of a feature.',
    'page callback' => 'features_export_components_json',
    'page arguments' => array(2),
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
  );
  foreach ($items as $path => $item) {
    if (!isset($item['access callback'])) {
      $items[$path]['access callback'] = 'user_access';
      $items[$path]['access arguments'] = array('manage features');
    }
  }
  return $items;
}

/**
 * Implements hook_theme().
 */
function features_theme() {
  $base = array(
    'path' => drupal_get_path('module', 'features') . '/theme',
    'file' => 'theme.inc',
  );

  $items = array();
  $items['features_module_status'] = array(
    'variables' => array('module' => NULL, 'status' => NULL)
  ) + $base;

  $items['features_components'] = array(
    'variables' => array('info' => NULL, 'sources' => NULL),
  ) + $base;

  $items['features_component_key'] = $base;
  $items['features_component_list'] = array(
    'variables' => array('components' => array(), 'source' => array(), 'conflicts' => array()),
  ) + $base;

  $items['features_storage_link'] = array(
    'variables' => array('storage' => NULL, 'text' => NULL, 'path' => NULL, 'options' => array()),
  ) + $base;

  $items['features_lock_link'] = array(
    'variables' => array('feature' => NULL, 'component' => NULL, 'locked' => FALSE),
  ) + $base;

  $items['features_form_components'] =
  $items['features_form_export'] =
  $items['features_form_package'] = array(
    'render element' => 'form',
  ) + $base;

  $items['features_form_buttons'] = array(
    'render element' => 'element',
  ) + $base;


  $items['features_admin_components'] = array(
    'render element' => 'form',
    'template' => 'features-admin-components',
  ) + $base;

  return $items;
}

/**
 * Implements hook_flush_caches().
 */
function features_flush_caches() {
  if (($modules_changed = variable_get('features_modules_changed', FALSE)) || variable_get('features_rebuild_on_flush', TRUE)) {
    if ($modules_changed) {
      variable_set('features_modules_changed', FALSE);
    }
    features_rebuild();
    // Don't flush the modules cache during installation, for performance reasons.
    if (variable_get('install_task') == 'done') {
      features_get_modules(NULL, TRUE);
    }
  }
  return array('cache_features');
}

/**
 * Implements hook_form().
 */
function features_form($node, $form_state) {
  return node_content_form($node, $form_state);
}

/**
 * Implements hook_permission().
 */
function features_permission() {
  return array(
    'administer features' => array(
      'title' => t('Administer features'),
      'description' => t('Perform administration tasks on features.'),
      'restrict access' => TRUE,
    ),
    'manage features' => array(
      'title' => t('Manage features'),
      'description' => t('View, enable and disable features.'),
      'restrict access' => TRUE,
    ),
    'generate features' => array(
      'title' => t('Generate features'),
      'description' => t('Allow feature exports to be generated and written directly to site.'),
      'restrict access' => TRUE,
    ),
    'rename features' => array(
      'title' => t('Edit feature machine name'),
      'description' => t('Allows editing machine name of a disabled feature'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_help().
 */
function features_help($path, $arg) {
  switch ($path) {
    case 'admin/help#features':
      $output = file_get_contents(drupal_get_path('module', 'features') . '/README.txt');
      return module_exists('markdown') ? filter_xss_admin(module_invoke('markdown', 'filter', 'process', 0, -1, $output)) : '<pre>' . check_plain($output) . '</pre>';
    case 'admin/build/features':
      return '<p>' . t('A "Feature" is a certain type of Drupal module which contains a package of configuration that, when enabled, provides a new set of functionality for your Drupal site. Enable features by selecting the checkboxes below and clicking the Save configuration button. If the configuration of the feature has been changed its "State" will be either "overridden" or "needs review", otherwise it will be "default", indicating that the configuration has not been changed. Click on the state to see more details about the feature and its components.') . '</p>';
  }
}

/**
 * Implements hook_modules_disabled().
 */
function features_modules_disabled($modules) {
  // Go through all modules and gather features that can be disabled.
  $items = array();
  foreach ($modules as $module) {
    if ($feature = features_load_feature($module)) {
      $items[$module] = array_keys($feature->info['features']);
    }
  }

  if (!empty($items)) {
    _features_restore('disable', $items);
    // Rebuild the list of features includes.
    features_include(TRUE);
  }
}

/**
 * Implements hook_modules_enabled().
 */
function features_modules_enabled($modules) {
  // Allow distributions to disable this behavior and rebuild the features
  // manually inside a batch.
  if (!variable_get('features_rebuild_on_module_install', TRUE)) {
    return;
  }

  // mark modules as being changed for test in features_flush_caches
  variable_set('features_modules_changed', TRUE);

  // Go through all modules and gather features that can be enabled.
  $items = array();
  foreach ($modules as $module) {
    if ($feature = features_load_feature($module)) {
      $items[$module] = array_keys($feature->info['features']);
    }
  }

  if (!empty($items)) {
    // Need to include any new files.
    // @todo Redo function so can take in list of modules to include.
    features_include_defaults(NULL, TRUE);
    _features_restore('enable', $items);
    // Rebuild the list of features includes.
    features_include(TRUE);
    // Reorders components to match hook order and removes non-existant.
    $all_components = array_keys(features_get_components());
    foreach ($items as $module => $components) {
      $items[$module] = array_intersect($all_components, $components);
    }
    _features_restore('rebuild', $items);
  }
}

/**
 * Load includes for any modules that implement the features API and
 * load includes for those provided by features.
 */
function features_include($reset = FALSE) {
  static $once;
  if (!isset($once) || $reset) {
    $once = TRUE;

    // Features provides integration on behalf of these modules.
    // The features include provides handling for the feature dependencies.
    // Note that ctools is placed last because it implements hooks "dynamically" for other modules.
    $modules = array('features', 'block', 'contact', 'context', 'field', 'filter', 'image', 'locale', 'menu', 'node', 'taxonomy', 'user', 'views', 'ctools');

    foreach (array_filter($modules, 'module_exists') as $module) {
      module_load_include('inc', 'features', "includes/features.$module");
    }

    if (module_exists('ctools')) {
      // Finally, add ctools eval'd implementations.
      ctools_features_declare_functions($reset);
    }

    // Clear static cache, since we've now included new implementers.
    foreach (features_get_components(NULL, 'file', $reset) as $file) {
      if (is_file(DRUPAL_ROOT . '/' . $file)) {
        require_once DRUPAL_ROOT . '/' . $file;
      }
    }
  }
}

/**
 * Load features includes for all components that require includes before
 * collecting defaults.
 */
function features_include_defaults($components = NULL, $reset = FALSE) {
  static $include_components;

  // Build an array of components that require inclusion:
  // Views, CTools components and those using FEATURES_DEFAULTS_INCLUDED.
  if (!isset($include_components) || $reset) {
    $include_components = features_get_components();
    foreach ($include_components as $component => $info) {
      if (!isset($info['api']) && (!isset($info['default_file']) || $info['default_file'] !== FEATURES_DEFAULTS_INCLUDED)) {
        unset($include_components[$component]);
      }
    }
  }

  // If components are specified, only include for the specified components.
  if (isset($components)) {
    $components = is_array($components) ? $components : array($components);
  }
  // Use all include components if none are explicitly specified.
  else {
    $components = array_keys($include_components);
  }
  foreach ($components as $component) {
    if (isset($include_components[$component])) {
      $info = $include_components[$component];
      // Inclusion of ctools components.
      if (isset($info['api'], $info['module'], $info['current_version'])) {
        ctools_include('plugins');
        ctools_plugin_api_include($info['module'], $info['api'], $info['current_version'], $info['current_version']);
      }
      // Inclusion of defaults for components using FEATURES_DEFAULTS_INCLUDED.
      else {
        $features = isset($features) ? $features : features_get_features(NULL, $reset);
        foreach ($features as $feature) {
          $filename = isset($info['default_file']) && $info['default_file'] == FEATURES_DEFAULTS_CUSTOM ? $info['default_filename'] : "features.{$component}";
          if (module_exists($feature->name) && isset($feature->info['features'][$component])) {
            module_load_include('inc', $feature->name, "{$feature->name}.$filename");
          }
        }
      }
    }
  }
}

/**
 * Feature object loader.  DEPRECATED but included for backwards compatibility
 */
function feature_load($name, $reset = FALSE) {
  return features_load_feature($name, $reset);
}

/**
 * Feature object loader.
 */
function features_load_feature($name, $reset = FALSE) {
  // Use an alternative code path during installation, for better performance.
  if (variable_get('install_task') != 'done') {
    static $features;

    if (!isset($features[$name])) {
      // Set defaults for module info.
      $defaults = array(
        'dependencies' => array(),
        'description' => '',
        'package' => 'Other',
        'version' => NULL,
        'php' => DRUPAL_MINIMUM_PHP,
        'files' => array(),
        'bootstrap' => 0,
      );
      $info = drupal_parse_info_file(drupal_get_path('module', $name) . '/' . $name . '.info');

      $features[$name] = FALSE;
      if (!empty($info['features']) && empty($info['hidden'])) {
        // Build a fake file object with the data needed during installation.
        $features[$name] = new stdClass;
        $features[$name]->name = $name;
        $features[$name]->filename = drupal_get_path('module', $name) . '/' . $name . '.module';
        $features[$name]->type = 'module';
        $features[$name]->info = $info + $defaults;
      }
    }

    return $features[$name];
  }
  else {
    return features_get_features($name, $reset);
  }
}

/**
 * Return a module 'object' including .info information.
 *
 * @param $name
 *   The name of the module to retrieve information for. If ommitted,
 *   an array of all available modules will be returned.
 * @param $reset
 *   Whether to reset the cache.
 *
 * @return
 *   If a module is request (and exists) a module object is returned. If no
 *   module is requested info for all modules is returned.
 */
function features_get_modules($name = NULL, $reset = FALSE) {
  return features_get_info('module', $name, $reset);
}

/**
 * Returns the array of supported components.
 *
 * @see hook_features_api
 *
 * @param $component
 *   A specific type of component that supports features.
 * @param $key
 *   A key that hook_features_api supports.
 *
 * @return An array of component labels keyed by the component names.
 */
function features_get_components($component = NULL, $key = NULL, $reset = FALSE) {
  features_include();
  $components = &drupal_static(__FUNCTION__);
  $component_by_key = &drupal_static(__FUNCTION__ . '_by_key');

  if ($reset || !isset($components) || !isset($component_by_key)) {
    $components = $component_by_key = array();
    if (!$reset && ($cache = cache_get('features_api', 'cache_features'))) {
      $components = $cache->data;
    }
    else {
      $components = module_invoke_all('features_api');
      drupal_alter('features_api', $components);
      cache_set('features_api', $components, 'cache_features');
    }

    foreach ($components as $component_type => $component_information) {
      foreach ($component_information as $component_key => $component_value) {
        $component_by_key[$component_key][$component_type] = $component_value;
      }
    }
  }

  if ($key && $component) {
    return !empty($components[$component][$key]) ? $components[$component][$key] : NULL;
  }
  elseif ($key) {
    return !empty($component_by_key[$key]) ? $component_by_key[$key] : array();
  }
  elseif ($component) {
    return $components[$component];
  }
  return $components;
}

/**
 * Returns components that are offered as an option on feature creation.
 */
function features_get_feature_components() {
  return array_intersect_key(features_get_components(), array_filter(features_get_components(NULL, 'feature_source')));
}

/**
 * Invoke a component callback.
 */
function features_invoke($component, $callback) {
  $args = func_get_args();
  unset($args[0], $args[1]);
  // Append the component name to the arguments.
  $args[] = $component;
  if ($function = features_hook($component, $callback)) {
    return call_user_func_array($function, $args);
  }
}

/**
 * Checks whether a component implements the given hook.
 *
 * @return
 *   The function implementing the hook, or FALSE.
 */
function features_hook($component, $hook, $reset = FALSE) {
  // Determine the function callback base.
  $base = features_get_components($component, 'base');
  $base = isset($base) ? $base : $component;
  return function_exists($base . '_' . $hook) ? $base . '_' . $hook : FALSE;
}

/**
 * Enables and installs an array of modules, ignoring those
 * already enabled & installed. Consider this a helper or
 * extension to drupal_install_modules().
 *
 * @param $modules
 *   An array of modules to install.
 * @param $reset
 *   Clear the module info cache.
 */
function features_install_modules($modules) {
  variable_set('features_modules_changed', TRUE);

  module_load_include('inc', 'features', 'features.export');
  $files = system_rebuild_module_data();

  // Build maximal list of dependencies.
  $install = array();
  foreach ($modules as $name) {
    // Parse the dependency string into the module name and version information.
    $parsed_name = drupal_parse_dependency($name);
    $name = $parsed_name['name'];
    if ($file = $files[$name]) {
      $install[] = $name;
      if (!empty($file->info['dependencies'])) {
        $install = array_merge($install, _features_export_maximize_dependencies($file->info['dependencies']));
      }
    }
  }

  // Filter out enabled modules.
  $enabled = array_filter($install, 'module_exists');
  $install = array_diff($install, $enabled);

  if (!empty($install)) {
    // Make sure the install API is available.
    $install = array_unique($install);
    include_once DRUPAL_ROOT . '/' . './includes/install.inc';
    module_enable($install);
  }
}

/**
 * Wrapper around features_get_info() that returns an array
 * of module info objects that are features.
 */
function features_get_features($name = NULL, $reset = FALSE) {
  return features_get_info('feature', $name, $reset);
}

/**
 * Helper for retrieving info from system table.
 */
function features_get_info($type = 'module', $name = NULL, $reset = FALSE) {
  static $cache;
  if (!isset($cache)) {
    $cache = cache_get('features_module_info', 'cache_features');
  }
  if (empty($cache) || $reset) {
    $data = array(
      'feature' => array(),
      'module' => array(),
    );
    $ignored = variable_get('features_ignored_orphans', array());
    $files = system_rebuild_module_data();

    foreach ($files as $row) {
      // Remove modification timestamp, added in Drupal 7.33.
      if (isset($row->info['mtime'])) {
        unset($row->info['mtime']);
      }
      // Avoid false-reported feature overrides for php = 5.2.4 line in .info file.
      if (isset($row->info['php'])) {
        unset($row->info['php']);
      }
      // If module is no longer enabled, remove it from the ignored orphans list.
      if (in_array($row->name, $ignored, TRUE) && !$row->status) {
        $key = array_search($row->name, $ignored, TRUE);
        unset($ignored[$key]);
      }

      if (!empty($row->info['features'])) {
        // Fix css/js paths
        if (!empty($row->info['stylesheets'])) {
          foreach ($row->info['stylesheets'] as $media => $css) {
            $row->info['stylesheets'][$media] = array_keys($css);
          }
        }
        if (!empty($row->info['scripts'])) {
          $row->info['scripts'] = array_keys($row->info['scripts']);
        }
        // Rework the features array, to change the vocabulary permission
        // features.
        foreach ($row->info['features'] as $component => $features) {
          if ($component == 'user_permission') {
            foreach ($features as $key => $feature) {
              // Export vocabulary permissions using the machine name, instead
              // of vocabulary id.
              _user_features_change_term_permission($feature);
              $row->info['features'][$component][$key] = $feature;
            }
          }
        }
        $data['feature'][$row->name] = $row;
        $data['feature'][$row->name]->components = array_keys($row->info['features']);
        if (!empty($row->info['dependencies'])) {
          $data['feature'][$row->name]->components[] = 'dependencies';
        }
      }
      $data['module'][$row->name] = $row;
    }

    // Sort features according to dependencies.
    // @see install_profile_modules()
    $required = array();
    $non_required = array();

    $modules = array_keys($data['feature']);
    foreach ($modules as $module) {
      if ($files[$module]->requires) {
        $modules = array_merge($modules, array_keys($files[$module]->requires));
      }
    }
    $modules = array_unique($modules);
    foreach ($modules as $module) {
      if (!empty($files[$module]->info['features'])) {
        if (!empty($files[$module]->info['required'])) {
          $required[$module] = $files[$module]->sort;
        }
        else {
          $non_required[$module] = $files[$module]->sort;
        }
      }
    }
    arsort($required);
    arsort($non_required);

    $sorted = array();
    foreach ($required + $non_required as $module => $weight) {
      $sorted[$module] = $data['feature'][$module];
    }
    $data['feature'] = $sorted;

    variable_set('features_ignored_orphans', $ignored);
    cache_set('features_module_info', $data, 'cache_features');
    $cache = new stdClass();
    $cache->data = $data;
  }
  if (!empty($name)) {
    return !empty($cache->data[$type][$name]) ? clone $cache->data[$type][$name] : array();
  }
  return !empty($cache->data[$type]) ? $cache->data[$type] : array();
}

/**
 * Generate an array of feature dependencies that have been orphaned.
 */
function features_get_orphans($reset = FALSE) {
  static $orphans;
  if (!isset($orphans) || $reset) {
    module_load_include('inc', 'features', 'features.export');
    $orphans = array();

    // Build a list of all dependencies for enabled and disabled features.
    $dependencies = array('enabled' => array(), 'disabled' => array());
    $features = features_get_features();
    foreach ($features as $feature) {
      $key = module_exists($feature->name) ? 'enabled' : 'disabled';
      if (!empty($feature->info['dependencies'])) {
        $dependencies[$key] = array_merge($dependencies[$key], _features_export_maximize_dependencies($feature->info['dependencies']));
      }
    }
    $dependencies['enabled'] = array_unique($dependencies['enabled']);
    $dependencies['disabled'] = array_unique($dependencies['disabled']);

    // Find the list of orphaned modules.
    $orphaned = array_diff($dependencies['disabled'], $dependencies['enabled']);
    $orphaned = array_intersect($orphaned, module_list(FALSE, FALSE));
    $orphaned = array_diff($orphaned, drupal_required_modules());
    $orphaned = array_diff($orphaned, array('features'));

    // Build final list of modules that can be disabled.
    $modules = features_get_modules(NULL, TRUE);
    $enabled = module_list();
    _module_build_dependencies($modules);

    foreach ($orphaned as $module) {
      if (!empty($modules[$module]->required_by)) {
        foreach ($modules[$module]->required_by as $module_name => $dependency) {
          $modules[$module]->required_by[$module_name] = $dependency['name'];
        }
        // Determine whether any dependents are actually enabled.
        $dependents = array_intersect($modules[$module]->required_by, $enabled);
        if (empty($dependents)) {
          $info = features_get_modules($module);
          $orphans[$module] = $info;
        }
      }
    }
  }
  return $orphans;
}

/**
 * Detect potential conflicts between any features that provide
 * identical components.
 */
function features_get_conflicts($reset = FALSE) {
  $conflicts = array();
  $component_info = features_get_components();
  $map = features_get_component_map(NULL, $reset);

  foreach ($map as $type => $components) {
    // Only check conflicts for components we know about.
    if (isset($component_info[$type])) {
      foreach ($components as $component => $modules) {
        if (isset($component_info[$type]['duplicates']) && $component_info[$type]['duplicates'] == FEATURES_DUPLICATES_ALLOWED) {
          continue;
        }
        elseif (count($modules) > 1) {
          foreach ($modules as $module) {
            if (!isset($conflicts[$module])) {
              $conflicts[$module] = array();
            }
            foreach ($modules as $m) {
              if ($m != $module) {
                $conflicts[$module][$m][$type][] = $component;
              }
            }
          }
        }
      }
    }
  }

  return $conflicts;
}

/**
 * Provide a component to feature map.
 */
function features_get_component_map($key = NULL, $reset = FALSE) {
  static $map;
  if (!isset($map) || $reset) {
    $map = array();
    $features = features_get_features(NULL, $reset);
    foreach ($features as $feature) {
      foreach ($feature->info['features'] as $type => $components) {
        if (!isset($map[$type])) {
          $map[$type] = array();
        }
        foreach ($components as $component) {
          $map[$type][$component][] = $feature->name;
        }
      }
    }
  }
  if (isset($key)) {
    return isset($map[$key]) ? $map[$key] : array();
  }
  return $map;
}

/**
 * Simple wrapper returns the status of a module.
 */
function features_get_module_status($module) {
  if (module_exists($module)) {
    return FEATURES_MODULE_ENABLED;
  }
  elseif (features_get_modules($module)) {
    return FEATURES_MODULE_DISABLED;
  }
  else {
    return FEATURES_MODULE_MISSING;
  }
}

/**
 * Menu title callback.
 */
function features_get_feature_title($feature) {
  return $feature->info['name'];
}

/**
 * Menu access callback for whether a user should be able to access
 * override actions for a given feature.
 */
function features_access_override_actions($feature) {
  if (user_access('administer features')) {
    static $access = array();
    if (!isset($access[$feature->name])) {
      // Set a value first. We may get called again from within features_detect_overrides().
      $access[$feature->name] = FALSE;

      features_include();
      module_load_include('inc', 'features', 'features.export');
      $access[$feature->name] = in_array(features_get_storage($feature->name), array(FEATURES_OVERRIDDEN, FEATURES_NEEDS_REVIEW)) && user_access('administer features');
    }
    return $access[$feature->name];
  }
  return FALSE;
}

/**
 * Implements hook_form_alter() for system_modules form().
 */
function features_form_system_modules_alter(&$form) {
  features_rebuild();
}

/**
 * Restore the specified modules to the default state.
 */
function _features_restore($op, $items = array()) {
  $lockable = FALSE;
  // Set this variable in $conf if having timeout issues during install/rebuild.
  if (variable_get('features_restore_time_limit_' . $op, FALSE) !== FALSE) {
    drupal_set_time_limit(variable_get('features_restore_time_limit_' . $op, FALSE));
  }

  module_load_include('inc', 'features', 'features.export');
  features_include();

  switch ($op) {
    case 'revert':
      $restore_states = array(FEATURES_OVERRIDDEN, FEATURES_REBUILDABLE, FEATURES_NEEDS_REVIEW);
      $restore_hook = 'features_revert';
      $log_action = 'Revert';
      $lockable = TRUE;
      break;
    case 'rebuild':
      $restore_states = array(FEATURES_REBUILDABLE);
      $restore_hook = 'features_rebuild';
      $log_action = 'Rebuild';
      $lockable = variable_get('features_lock_mode', 'all') == 'all';
      break;
    case 'disable':
      $restore_hook = 'features_disable_feature';
      $log_action = 'Disable';
      break;
    case 'enable':
      $restore_hook = 'features_enable_feature';
      $log_action = 'Enable';
      break;
  }

  if (empty($items)) {
    // Drush may execute a whole chain of commands that may trigger feature
    // rebuilding multiple times during a single request. Make sure we do not
    // rebuild the same cached list of modules over and over again by setting
    // $reset to TRUE.
    // Note: this may happen whenever more than one feature will be enabled
    // in chain, for example also using features_install_modules().
    $states = features_get_component_states(array(), ($op == 'rebuild'), defined('DRUSH_BASE_PATH'));
    foreach ($states as $module_name => $components) {
      foreach ($components as $component => $state) {
        if (in_array($state, $restore_states)) {
          $items[$module_name][] = $component;
        }
      }
    }
  }

  // Invoke global pre restore hook.
  module_invoke_all('features_pre_restore', $op, $items);
  foreach ($items as $module_name => $components) {
    // If feature is totally locked, do not execute past this stage.
    if ($lockable && features_feature_is_locked($module_name)) {
      watchdog('features', 'Tried @actioning a locked @module_name, aborted.', array('@action' => $log_action, '@module_name' => $module_name));
      continue;
    }
    foreach ($components as $component) {
      // If feature is totally locked, do not execute past this stage.
      if ($lockable && features_feature_is_locked($module_name, $component)) {
        watchdog('features', 'Tried @actioning a locked @module_name / @component, aborted.', array('@action' => $log_action, '@component' => $component, '@module_name' => $module_name));
        continue;
      }
      // Invoke pre hook
      $pre_hook = 'pre_' . $restore_hook;
      module_invoke($module_name, $pre_hook, $component);

      if (features_hook($component, $restore_hook)) {
        // Set a semaphore to prevent other instances of the same script from running concurrently.
        watchdog('features', '@actioning @module_name / @component.', array('@action' => $log_action, '@component' => $component, '@module_name' => $module_name));
        features_semaphore('set', $component);
        features_invoke($component, $restore_hook, $module_name);

        // If the script completes, remove the semaphore and set the code signature.
        features_semaphore('del', $component);
        features_set_signature($module_name, $component);
        watchdog('features', '@action completed for @module_name / @component.', array('@action' => $log_action, '@component' => $component, '@module_name' => $module_name));
      }

      // Invoke post hook
      $post_hook = 'post_' . $restore_hook;
      module_invoke($module_name, $post_hook, $component);
    }
  }
  // Invoke global post restore hook.
  module_invoke_all('features_post_restore', $op, $items);
}

/**
 * Wrapper around _features_restore().
 */
function features_revert($revert = array()) {
  return _features_restore('revert', $revert);
}

/**
 * Wrapper around _features_restore().
 */
function features_rebuild($rebuild = array()) {
  return _features_restore('rebuild', $rebuild);
}

/**
 * Revert a single features module.
 *
 * @param string $module
 *   A features module machine name. This module must be a
 *   features module and enabled.
 */
function features_revert_module($module) {
  if (($feature = feature_load($module, TRUE)) && module_exists($module)) {
    $components = array();
    foreach (array_keys($feature->info['features']) as $component) {
      if (features_hook($component, 'features_revert')) {
        $components[] = $component;
      }
    }
    features_revert(array($module => $components));
  }
}

/**
 * Utility functions ==================================================
 */

/**
 * Log a message, environment agnostic.
 *
 * @param $message
 *   The message to log.
 * @param $severity
 *   The severity of the message: status, warning or error.
 */
function features_log($message, $severity = 'status') {
  if (function_exists('drush_verify_cli')) {
    $message = strip_tags($message);
    if ($severity == 'status') {
      $severity = 'ok';
    }
    elseif ($severity == 'error') {
      drush_set_error($message);
      return;
    }
    drush_log($message, $severity);
    return;
  }
  drupal_set_message($message, $severity, FALSE);
}

/**
 * Implements hook_hook_info().
 */
function features_hook_info() {
  $hooks = array(
    'features_api',
    'features_pipe_alter',
    'features_export_alter',
    'features_export_options_alter',
  );
  return array_fill_keys($hooks, array('group' => 'features'));
}

/**
 * Change vocabularies permission, from vocab id to machine name and vice versa.
 */
function _user_features_change_term_permission(&$perm, $type = 'vid') {
  if (!module_exists('taxonomy')) {
    return;
  }
  // Export vocabulary permissions using the machine name, instead of vocabulary
  // id.
  if (strpos($perm, 'edit terms in ') !== FALSE || strpos($perm, 'delete terms in ') !== FALSE) {
    preg_match("/(?<=\040)([^\s]+?)$/", trim($perm), $voc_id);
    $vid = $voc_id[0];
    if (is_numeric($vid) && $type == 'vid') {
      if (function_exists('taxonomy_vocabulary_load')) {
        if ($voc = taxonomy_vocabulary_load($vid)) {
          $perm = str_replace($vid, $voc->machine_name, $perm);
        }
      }
    }
    elseif ($type == 'machine_name') {
      if ($voc = taxonomy_vocabulary_machine_name_load($vid)) {
        $perm = str_replace($vid, $voc->vid, $perm);
      }
    }
  }
}

/**
 * Recursively computes the difference of arrays with additional index check.
 *
 * This is a version of array_diff_assoc() that supports multidimensional
 * arrays.
 *
 * @param array $array1
 *   The array to compare from.
 * @param array $array2
 *   The array to compare to.
 *
 * @return array
 *   Returns an array containing all the values from array1 that are not present
 *   in array2.
 */
function features_array_diff_assoc_recursive(array $array1, array $array2) {
  $difference = array();
  foreach ($array1 as $key => $value) {
    if (is_array($value)) {
      if (!isset($array2[$key]) || !is_array($array2[$key])) {
        $difference[$key] = $value;
      }
      else {
        $new_diff = features_array_diff_assoc_recursive($value, $array2[$key]);
        if (!empty($new_diff)) {
          $difference[$key] = $new_diff;
        }
      }
    }
    elseif (!isset($array2[$key]) || $array2[$key] != $value) {
      $difference[$key] = $value;
    }
  }
  return $difference;
}

/**
 * Returns an array of deprecated components
 * Rather than deprecating the component directly, we look for other components
 * that supersedes the component
 * @param $components
 *   The array of components (component_info) from features_get_components typically.
 */
function features_get_deprecated($components = array()) {
  if (empty($components)) {
    $components = features_get_components();
  }
  $deprecated = array();
  foreach ($components as $component => $component_info) {
    if (!empty($component_info['supersedes'])) {
      $deprecated[$component_info['supersedes']] = $component_info['supersedes'];
    }
  }
  return $deprecated;
}

/**
 * Returns whether a feature or it's component is locked.
 */
function features_feature_is_locked($feature, $component = NULL, $check_global_component_setting = TRUE) {
  $locked = variable_get('features_feature_locked', array());
  if ($component) {
    return ($check_global_component_setting && features_component_is_locked($component)) || !empty($locked[$feature][$component]);
  }
  else {
    return !empty($locked[$feature]['_all']);
  }
}

/**
 * Returns whether a component is locked.
 */
function features_component_is_locked($component) {
  return variable_get('features_component_locked_' . $component, FALSE);
}

/**
 * Locks a feature or it's component.
 */
function features_feature_lock($feature, $component = NULL) {
  $locked = variable_get('features_feature_locked', array());
  $locked[$feature] = !empty($locked[$feature]) ? $locked[$feature] : array();
  if ($component) {
    $locked[$feature][$component] = TRUE;
  }
  else {
    $locked[$feature]['_all'] = TRUE;
  }
  variable_set('features_feature_locked', $locked);
}

/**
 * Unlocks a feature or it's component.
 */
function features_feature_unlock($feature, $component = NULL) {
  $locked = variable_get('features_feature_locked', array());
  if ($component) {
    unset($locked[$feature][$component]);
  }
  else {
    unset($locked[$feature]['_all']);
  }
  variable_set('features_feature_locked', $locked);
}

/**
 * Sets the current language to english to ensure a proper export.
 */
function _features_set_export_language() {
  // Ensure this is only done if the language isn't already en.
  // This can be called multiple times - ensure the handling is done just once.
  if ($GLOBALS['language']->language != 'en' && !drupal_static(__FUNCTION__)) {
    // Create the language object as language_default() does.
    $GLOBALS['language'] = (object) array(
      'language' => 'en',
      'name' => 'English',
      'native' => 'English',
      'direction' => 0,
      'enabled' => 1,
      'plurals' => 0,
      'formula' => '',
      'domain' => '',
      'prefix' => '',
      'weight' => 0,
      'javascript' => '',
    );
    // Ensure that static caches are cleared, as they might contain language
    // specific information. But keep some important ones. The call below
    // accesses a non existing key and requests to reset it. In such cases the
    // whole caching data array is returned.
    $static = drupal_static(uniqid('', TRUE), NULL, TRUE);
    drupal_static_reset();
    // Restore some of the language independent, runtime state information to
    // keep everything working and avoid unnecessary double processing.
    $static_caches_to_keep = array(
      'conf_path',
      'system_list',
      'ip_address',
      'drupal_page_is_cacheable',
      'list_themes',
      'drupal_page_header',
      'drupal_send_headers',
      'drupal_http_headers',
      'language_list',
      'module_implements',
      'drupal_alter',
      'path_is_admin',
      'path_get_admin_paths',
      'drupal_match_path',
      'menu_get_custom_theme',
      'menu_get_item',
      'arg',
      'drupal_system_listing',
      'drupal_parse_info_file',
      'libraries_get_path',
      'module_hook_info',
      'drupal_add_js',
      'drupal_add_js:jquery_added',
      'drupal_add_library',
      'drupal_get_library',
      'drupal_add_css',
      'menu_set_active_trail',
      'menu_link_get_preferred',
      'menu_set_active_menu_names',
      'theme_get_registry',
      'features_get_components',
      'features_get_components_by_key',
    );
    foreach ($static_caches_to_keep as $cid) {
      if (isset($static[$cid])) {
        $data = &drupal_static($cid);
        $data = $static[$cid];
      }
    }
    $called = &drupal_static(__FUNCTION__);
    $called = TRUE;
  }
}

/**
 * Implements hook_features_ignore().
 */
function features_features_ignore($component) {
  // Determine which keys need to be ignored for override diff for various components.
  // Value is how many levels deep the key is.
  $ignores = array();
  switch ($component) {
    case 'views_view':
      $ignores['current_display'] = 0;
      $ignores['display_handler'] = 0;
      $ignores['handler'] = 2;
      $ignores['query'] = 0;
      $ignores['localization_plugin'] = 0;
      // Views automatically adds these two on export to set values.
      $ignores['api_version'] = 0;
      $ignores['disabled'] = 0;
      break;
    case 'image':
      $ignores['module'] = 0;
      $ignores['name'] = 0;
      $ignores['storage'] = 0;
      // Various properties are loaded into the effect in image_styles.
      $ignores['summary theme'] = 2;
      $ignores['module'] = 2;
      $ignores['label'] = 2;
      $ignores['help'] = 2;
      $ignores['form callback'] = 2;
      $ignores['effect callback'] = 2;
      $ignores['dimensions callback'] = 2;
      break;
    case 'field':
      $ignores['locked'] = 1;
      break;
  }
  return $ignores;
}
