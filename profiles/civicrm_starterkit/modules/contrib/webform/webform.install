<?php

/**
 * @file
 *   Webform module install/schema hooks.
 */

/**
 * Implements hook_schema().
 */
function webform_schema() {
  $schema = array();

  $schema['webform'] = array(
    'description' => 'Table for storing additional properties for webform nodes.',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'confirmation' => array(
        'description' => 'The confirmation message or URL displayed to the user after submitting a form.',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'confirmation_format' => array(
        'description' => 'The {filter_format}.format of the confirmation message.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => FALSE,
      ),
      'redirect_url' => array(
        'description' => 'The URL a user is redirected to after submitting a form.',
        'type' => 'varchar',
        'length' => 255,
        'default' => '<confirmation>',
      ),
      'status' => array(
        'description' => 'Boolean value of a webform for open (1) or closed (0).',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 1,
      ),
      'block' => array(
         'description' => 'Boolean value for whether this form be available as a block.',
         'type' => 'int',
         'size' => 'tiny',
         'not null' => TRUE,
         'default' => 0,
      ),
      'allow_draft' => array(
         'description' => 'Boolean value for whether submissions to this form be saved as a draft.',
         'type' => 'int',
         'size' => 'tiny',
         'not null' => TRUE,
         'default' => 0,
      ),
      'auto_save' => array(
         'description' => 'Boolean value for whether submissions to this form should be auto-saved between pages.',
         'type' => 'int',
         'size' => 'tiny',
         'not null' => TRUE,
         'default' => 0,
      ),
      'submit_notice' => array(
        'description' => 'Boolean value for whether to show or hide the previous submissions notification.',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 1,
      ),
      'submit_text' => array(
        'description' => 'The title of the submit button on the form.',
        'type' => 'varchar',
        'length' => 255,
      ),
      'submit_limit' => array(
        'description' => 'The number of submissions a single user is allowed to submit within an interval. -1 is unlimited.',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => -1,
      ),
      'submit_interval' => array(
        'description' => 'The amount of time in seconds that must pass before a user can submit another submission within the set limit.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => -1,
      ),
      'total_submit_limit' => array(
        'description' => 'The total number of submissions allowed within an interval. -1 is unlimited.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => -1,
      ),
      'total_submit_interval' => array(
        'description' => 'The amount of time in seconds that must pass before another submission can be submitted within the set limit.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => -1,
      ),
      'progressbar_bar' => array(
        'description' => 'Boolean value indicating if the bar should be shown as part of the progress bar.',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'progressbar_page_number' => array(
        'description' => 'Boolean value indicating if the page number should be shown as part of the progress bar.',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'progressbar_percent' => array(
        'description' => 'Boolean value indicating if the percentage complete should be shown as part of the progress bar.',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'progressbar_pagebreak_labels' => array(
        'description' => 'Boolean value indicating if the pagebreak labels should be included as part of the progress bar.',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'progressbar_include_confirmation' => array(
        'description' => 'Boolean value indicating if the confirmation page should count as a page in the progress bar.',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'progressbar_label_first' => array(
        'description' => 'Label for the first page of the progress bar.',
        'type' => 'varchar',
        'length' => 255,
      ),
      'progressbar_label_confirmation' => array(
        'description' => 'Label for the last page of the progress bar.',
        'type' => 'varchar',
        'length' => 255,
      ),
    ),
    'primary key' => array('nid'),
  );

  $schema['webform_component'] = array(
    'description' => 'Stores information about components for webform nodes.',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'cid' => array(
        'description' => 'The identifier for this component within this node, starts at 0 for each node.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'pid' => array(
        'description' => 'If this component has a parent fieldset, the cid of that component.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'form_key' => array(
        'description' => 'When the form is displayed and processed, this key can be used to reference the results.',
        'type' => 'varchar',
        'length' => 128,
      ),
      'name' => array(
        'description' => 'The label for this component.',
        'type' => 'varchar',
        'length' => 255,
      ),
      'type' => array(
        'description' => 'The field type of this component (textfield, select, hidden, etc.).',
        'type' => 'varchar',
        'length' => 16,
      ),
      'value' => array(
        'description' => 'The default value of the component when displayed to the end-user.',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'extra' => array(
        'description' => 'Additional information unique to the display or processing of this component.',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'required' => array(
        'description' => 'Boolean flag for if this component is required.',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'weight' => array(
        'description' => 'Determines the position of this component in the form.',
        'type' => 'int',
        'size' => 'small',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('nid', 'cid'),
  );

  $schema['webform_conditional'] = array(
    'description' => 'Holds information about conditional logic.',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'rgid' => array(
        'description' => 'The rule group identifier for this group of rules.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'andor' => array(
        'description' => 'Whether to AND or OR the actions in this group. All actions within the same crid should have the same andor value.',
        'type' => 'varchar',
        'length' => 128,
      ),
      'action' => array(
        'description' => 'The action to be performed on the target. Typically "show" or "hide" for targets of type "component", and "send" for targets of type "email".',
        'type' => 'varchar',
        'length' => 128,
      ),
      'target_type' => array(
        'description' => 'The type of target to be affected. Either "component" or "email". Indicates what type of ID the "target" column contains.',
        'type' => 'varchar',
        'length' => 128,
      ),
      'target' => array(
        'description' => 'The ID of the target to be affected. Typically a component ID.',
        'type' => 'varchar',
        'length' => 128,
      ),
      'weight' => array(
        'description' => 'Determines the position of this conditional compared to others.',
        'type' => 'int',
        'size' => 'small',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('nid', 'rgid'),
  );

  $schema['webform_conditional_rules'] = array(
    'description' => 'Holds information about conditional logic.',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'rgid' => array(
        'description' => 'The rule group identifier for this group of rules.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'rid' => array(
        'description' => 'The rule identifier for this conditional rule.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'source_type' => array(
        'description' => 'The type of source on which the conditional is based. Currently always "component". Indicates what type of ID the "source" column contains.',
        'type' => 'varchar',
        'length' => 128,
      ),
      'source' => array(
        'description' => 'The component ID being used in this condition.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'operator' => array(
        'description' => 'Which operator (equal, contains, starts with, etc.) should be used for this comparison between the source and value?',
        'type' => 'varchar',
        'length' => 128,
      ),
      'value' => array(
        'description' => 'The value to be compared with source.',
        'type' => 'text',
      ),
    ),
    'primary key' => array('nid', 'rgid', 'rid'),
  );

  $schema['webform_emails'] = array(
    'description' => 'Holds information regarding e-mails that should be sent upon submitting a webform',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'eid' => array(
        'description' => 'The e-mail identifier for this row\'s settings.',
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'small',
        'not null' => TRUE,
        'default' => 0,
      ),
      'email' => array(
        'description' => 'The e-mail address that will be sent to upon submission. This may be an e-mail address, the special key "default" or a numeric value. If a numeric value is used, the value of a component will be substituted on submission.',
        'type' => 'text',
        'not null' => FALSE,
      ),
      'subject' => array(
        'description' => 'The e-mail subject that will be used. This may be a string, the special key "default" or a numeric value. If a numeric value is used, the value of a component will be substituted on submission.',
        'type' => 'varchar',
        'length' => '255',
        'not null' => FALSE,
      ),
      'from_name' => array(
        'description' => 'The e-mail "from" name that will be used. This may be a string, the special key "default" or a numeric value. If a numeric value is used, the value of a component will be substituted on submission.',
        'type' => 'varchar',
        'length' => '255',
        'not null' => FALSE,
      ),
      'from_address' => array(
        'description' => 'The e-mail "from" e-mail address that will be used. This may be a string, the special key "default" or a numeric value. If a numeric value is used, the value of a component will be substituted on submission.',
        'type' => 'varchar',
        'length' => '255',
        'not null' => FALSE,
      ),
      'template' => array(
        'description' => 'A template that will be used for the sent e-mail. This may be a string or the special key "default", which will use the template provided by the theming layer.',
        'type' => 'text',
        'not null' => FALSE,
      ),
      'excluded_components' => array(
        'description' => 'A list of components that will not be included in the [submission:values] token. A list of CIDs separated by commas.',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'html' => array(
        'description' => 'Determines if the e-mail will be sent in an HTML format. Requires Mime Mail module.',
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'attachments' => array(
        'description' => 'Determines if the e-mail will include file attachments. Requires Mime Mail module.',
        'type' => 'int',
        'unsigned' => TRUE,
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'extra' => array(
        'description' => 'A serialized array of additional options for the e-mail configuration, including excluded components and value mapping for the TO and FROM addresses for select lists.',
        'type' => 'text',
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('nid', 'eid'),
  );

  $schema['webform_roles'] = array(
    'description' => 'Holds access information regarding which roles are allowed to submit which webform nodes. Does not prevent access to the webform node entirely, use the {node_access} table for that purpose.',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'rid' => array(
        'description' => 'The role identifier.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('nid', 'rid'),
  );

  $schema['webform_submissions'] = array(
    'description' => 'Holds general information about submissions outside of field values.',
    'fields' => array(
      'sid' => array(
        'description' => 'The unique identifier for this submission.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'uid' => array(
        'description' => 'The id of the user that completed this submission.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'is_draft' => array(
         'description' => 'Is this a draft of the submission?',
         'type' => 'int',
         'size' => 'tiny',
         'not null' => TRUE,
         'default' => 0,
      ),
      'submitted' => array(
        'description' => 'Timestamp of when the form was submitted.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'remote_addr' => array(
        'description' => 'The IP address of the user that submitted the form.',
        'type' => 'varchar',
        'length' => 128,
      ),
    ),
    'primary key' => array('sid'),
    'unique keys' => array(
      'sid_nid' => array('sid', 'nid'),
    ),
    'indexes' => array(
      'nid_uid_sid' => array('nid', 'uid', 'sid'),
      'nid_sid' => array('nid', 'sid'),
    ),
  );

  $schema['webform_submitted_data'] = array(
    'description' => 'Stores all submitted field data for webform submissions.',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'sid' => array(
        'description' => 'The unique identifier for this submission.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'cid' => array(
        'description' => 'The identifier for this component within this node, starts at 0 for each node.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'no' => array(
        'description' => 'Usually this value is 0, but if a field has multiple values (such as a time or date), it may require multiple rows in the database.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '0',
      ),
      'data' => array(
        'description' => 'The submitted value of this field, may be serialized for some components.',
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('nid', 'sid', 'cid', 'no'),
    'indexes' => array(
      'nid' => array('nid'),
      'sid_nid' => array('sid', 'nid'),
    ),
  );

  $schema['webform_last_download'] = array(
   'description' => 'Stores last submission number per user download.',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'uid' => array(
       'description' => 'The user identifier.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
     'sid' => array(
        'description' => 'The last downloaded submission number.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
     'requested' => array(
        'description' => 'Timestamp of last download request.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('nid', 'uid'),
  );

  return $schema;
}


/**
 * Implements hook_requirements().
 */
function webform_requirements($phase) {
  $requirements = array();
  $t = get_t();

  // Ensure cURL exists if SimpleTest hasn't checked it already.
  if (!class_exists('ZipArchive')) {
    $requirements['webform_zip'] = array(
      'title' => $t('Zip archive support'),
      'value' => $t('Missing'),
      'severity' => REQUIREMENT_WARNING,
      'description' => $t('PHP does not have the zip archive extension available. Webform module requires zip support for exporting submissions to Microsoft Excel.'),
    );
  }

  return $requirements;
}

/**
 * Implements hook_install().
 */
function webform_install() {
  module_load_include('inc', 'node', 'content_types');
  db_update('system')
    ->condition('name', 'webform')
    ->condition('type', 'module')
    ->fields(array('weight' => -1))
    ->execute();

  // Optionally create the default webform type.
  if (variable_get('webform_install_create_content_type', TRUE)) {
    $webform_type = array(
      'type' => 'webform',
      'name' => st('Webform'),
      'base' => 'node_content',
      'description' => st('Create a new form or questionnaire accessible to users. Submission results and statistics are recorded and accessible to privileged users.'),
      'custom' => TRUE,
      'modified' => TRUE,
      'locked' => FALSE,
    );
    $webform_type = node_type_set_defaults($webform_type);
    node_type_save($webform_type);
    if (variable_get('webform_install_add_body_field', FALSE)) {
      node_add_body_field($webform_type);
    }
    // Enable webform components by default on Webform nodes.
    variable_set('webform_node_webform', TRUE);
    // Disable comments by default on Webform nodes.
    variable_set('comment_webform', '0');
  }
}

/**
 * Implements hook_uninstall().
 */
function webform_uninstall() {
  // Unset webform variables.
  variable_del('webform_node_types_primary');
  variable_del('webform_disabled_components');
  variable_del('webform_tracking_mode');
  variable_del('webform_default_from_address');
  variable_del('webform_default_from_name');
  variable_del('webform_default_subject');
  variable_del('webform_default_format');
  variable_del('webform_format_override');
  variable_del('webform_csv_delimiter');
  variable_del('webform_allowed_tags');
  variable_del('webform_blocks');
  variable_del('webform_search_index');
  variable_del('webform_email_address_format');
  variable_del('webform_export_format');
  variable_del('webform_submission_access_control');
  variable_del('webform_update_batch_size');
  variable_del('webform_email_select_max');
  variable_del('webform_tracking_mode');
  variable_del('webform_progressbar_style');
  variable_del('webform_progressbar_label_first');
  variable_del('webform_progressbar_label_confirmation');
  variable_del('webform_excel_legacy_exporter');

  foreach (node_type_get_names() as $type => $name) {
    variable_del('webform_node_' . $type);
  }

  $component_list = array();
  $path = drupal_get_path('module', 'webform') . '/components';
  $files = file_scan_directory($path, '/^.*\.inc$/');
  foreach ($files as $filename => $file) {
    variable_del('webform_enable_' . $file->name, 1);
  }

  // Delete uploaded files.
  $filepath = file_build_uri('webform');
  file_unmanaged_delete_recursive($filepath);
}

/**
 * Set the minimum upgrade version.
 *
 * Currently you cannot upgrade from 2.x in Drupal 6 to 3.x in Drupal 7. However
 * there are no database changes between the 3.x versions, so no update is
 * needed at all to move from 3.x in Drupal 6 to Drupal 7.
 */
function webform_update_last_removed() {
  return 6313;
}

/**
 * Allow the confirmation format column to have a NULL value.
 */
function webform_update_7301() {
  // These changes are modeled after user_update_7010().
  db_change_field('webform', 'confirmation_format', 'confirmation_format', array(
    'description' => 'The {filter_format}.format of the confirmation message.',
    'type' => 'int',
    'unsigned' => TRUE,
    'not null' => FALSE,
  ));
  db_update('webform')
    ->fields(array('confirmation_format' => NULL))
    ->condition('confirmation', '')
    ->condition('confirmation_format', 0)
    ->execute();
  $existing_formats = db_query("SELECT format FROM {filter_format}")->fetchCol();
  $default_format = variable_get('filter_default_format', 1);

  // Since Webform may be updated separately from Drupal core, not all format
  // names may be numbers when running this update.
  $numeric_formats = array();
  foreach ($existing_formats as $format_name) {
    if (is_numeric($format_name)) {
      $numeric_formats[] = (int) $format_name;
    }
  }

  $query = db_update('webform')
    ->fields(array('confirmation_format' => $default_format))
    ->isNotNull('confirmation_format');

  if (!empty($numeric_formats)) {
    $query->condition('confirmation_format', $numeric_formats, 'NOT IN');
  }

  $query->execute();
}

/**
 * Add columns for e-mail HTML and attachment settings.
 */
function webform_update_7302() {
  if (!db_field_exists('webform_emails', 'html')) {
    db_add_field('webform_emails', 'html', array('type' => 'int', 'size' => 'tiny', 'unsigned' => TRUE, 'default' => 0, 'not null' => TRUE));
    db_add_field('webform_emails', 'attachments', array('type' => 'int', 'size' => 'tiny', 'unsigned' => TRUE, 'default' => 0, 'not null' => TRUE));
  }
}

/**
 * Set the default for the "submit_notice" column to 1.
 */
function webform_update_7303() {
  db_change_field('webform', 'submit_notice', 'submit_notice', array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 1));
}

/**
 * Add field for block feature and redirection setting.
 */
function webform_update_7304() {
  if (!db_field_exists('webform', 'block')) {
    db_add_field('webform', 'block', array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0));
    db_change_field('webform', 'redirect_url', 'redirect_url', array('type' => 'varchar', 'length' => 255, 'default' => '<confirmation>'));
    db_update('webform')
      ->fields(array('redirect_url' => 'confirmation'))
      ->condition('redirect_url', '')
      ->execute();
  }
}

/**
 * Set additional_validate and additional_submit columns to allow NULL.
 */
function webform_update_7305() {
  if (db_field_exists('webform', 'additional_validate')) {
    db_change_field('webform', 'additional_validate', 'additional_validate', array('type' => 'text', 'not null' => FALSE));
    db_change_field('webform', 'additional_submit', 'additional_submit', array('type' => 'text', 'not null' => FALSE));
  }
}

/**
 * Add column for webform status (open or closed).
 */
function webform_update_7306() {
  if (!db_field_exists('webform', 'status')) {
    db_add_field('webform', 'status', array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 1));
  }
}

/**
 * Update the confirmation_format column for default text format changes.
 */
function webform_update_7307() {
  // Update removed and moved to webform_update_7301().
  // See http://drupal.org/node/976102.
}

/**
 * Update the confirmation_format column to allow it to store strings.
 */
function webform_update_7308() {
  db_change_field('webform', 'confirmation_format', 'confirmation_format', array(
    'description' => 'The {filter_format}.format of the confirmation message.',
    'type' => 'varchar',
    'length' => 255,
    'not null' => FALSE,
  ));
}

/**
 * Add the ability to auto-save as draft between pages.
 */
function webform_update_7309() {
  if (!db_field_exists('webform', 'auto_save')) {
    db_add_field('webform', 'auto_save', array('type' => 'int', 'size' => 'tiny', 'not null' => TRUE, 'default' => 0));
  }
}

/**
 * Remove orphaned and unnecessary rows in the webform table.
 */
function webform_update_7310() {
  $result = db_query("SELECT nid FROM {webform} WHERE
    nid NOT IN
    (SELECT DISTINCT(w1.nid) FROM {webform} w1 INNER JOIN {webform_component} wc ON w1.nid = wc.nid)
    AND nid NOT IN
    (SELECT w2.nid FROM {webform} w2 INNER JOIN {node} n ON w2.nid = n.nid WHERE n.type = 'webform')"
  );
  $empty_nids = array();
  foreach ($result as $row) {
    $empty_nids[] = $row->nid;
  }
  if (!empty($empty_nids)) {
    db_delete('webform')->condition('nid', $empty_nids, 'IN')->execute();
  }
}

/**
 * Add an index for nid_uid_sid to webform_submissions.
 */
function webform_update_7311() {
  if (!db_index_exists('webform_submissions', 'nid_uid_sid')) {
    db_add_index('webform_submissions', 'nid_uid_sid', array('nid', 'uid', 'sid'));
  }
}

/**
 * Remove unused Webform variables.
 */
function webform_update_7312() {
  variable_del('node_types');
  variable_del('components');
}

/**
 * Convert the Date component start and end year options to start and end date.
 */
function webform_update_7313() {
  $result = db_select('webform_component', 'wc', array('fetch' => PDO::FETCH_ASSOC))
    ->fields('wc')
    ->condition('type', 'date')
    ->execute();
  foreach ($result as $component) {
    $component['extra'] = unserialize($component['extra']);
    if (!isset($component['extra']['start_date']) && !isset($component['end_date'])) {
      foreach (array('year_start' => 'start_date', 'year_end' => 'end_date') as $key => $replacement) {
        $value = isset($component['extra'][$key]) ? trim($component['extra'][$key]) : '';
        // Relative years.
        if (preg_match('/[-+][ ]*[0-9]+/', $value)) {
          $component['extra'][$replacement] = ($value == 1) ? ($value . ' year') : ($value . ' years');
        }
        // Absolute years.
        elseif (is_numeric($value)) {
          $component['extra'][$replacement] = 'Dec 31 ' . $value;
        }
        unset($component['extra'][$key]);
      }
      $component['extra'] = serialize($component['extra']);
      drupal_write_record('webform_component', $component, array('nid', 'cid'));
    }
  }
}

/**
 * Add webform_last_download table to store last downloaded sid per user.
 */
function webform_update_7314() {
  // Safety check to prevent recreating the webform_last_download table.
  if (db_table_exists('webform_last_download')) {
    return;
  }

  $schema['webform_last_download'] = array(
    'description' => 'Stores last submission number per user download.',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'uid' => array(
        'description' => 'The user identifier.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'sid' => array(
        'description' => 'The last downloaded submission number.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('nid', 'uid'),
  );
  db_create_table('webform_last_download', $schema['webform_last_download']);
}

/**
 * Add column for timestamp of last requested CSV download.
 */
function webform_update_7315() {
  if (!db_field_exists('webform_last_download', 'requested')) {
    db_add_field('webform_last_download', 'requested', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0,));
  }
}

/**
 * Add additional columns for total submission limit.
 */
function webform_update_7316() {
  if (!db_field_exists('webform', 'total_submit_limit')) {
    db_add_field('webform', 'total_submit_limit', array('type' => 'int', 'not null' => TRUE, 'default' => -1));
  }

  if (!db_field_exists('webform', 'total_submit_interval')) {
    db_add_field('webform', 'total_submit_interval', array('type' => 'int', 'not null' => TRUE, 'default' => -1));
  }
}

/**
 * Add an index for 'nid_sid' to webform_submissions.
 */
function webform_update_7317() {
  // Even though we already have an index 'nid_uid_sid', adding the index for
  // 'nid_sid' saves us a tablesort on the node/x/webform-results page.
  if (!db_index_exists('webform_submissions', 'nid_sid')) {
    db_add_index('webform_submissions', 'nid_sid', array('nid', 'sid'));
  }
}

/**
 * Upgrade file components to support the new AJAX-upload element.
 */
function webform_update_7318() {
  $result = db_select('webform_component', 'wc', array('fetch' => PDO::FETCH_ASSOC))
    ->fields('wc')
    ->condition('type', 'file')
    ->execute();
  foreach ($result as $component) {
    $component['extra'] = unserialize($component['extra']);
    if (!isset($component['extra']['directory'])) {
      $component['extra']['directory'] = $component['extra']['savelocation'];
      $component['extra']['scheme'] = file_default_scheme();
      $component['extra']['filtering']['size'] = $component['extra']['filtering']['size'] . ' KB';
      unset($component['extra']['savelocation']);
      $component['extra'] = serialize($component['extra']);
      drupal_write_record('webform_component', $component, array('nid', 'cid'));
    }
  }

  return t('File components updated to support AJAX uploading.');
}

/**
 * Add file usage entries for all files uploaded through Webform.
 */
function webform_update_7319(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    // Initialize batch update information.
    $sandbox['progress'] = 0;
    $sandbox['last_fid_processed'] = -1;
    $sandbox['max'] = db_select('file_managed')
      ->condition('uri', '%' . db_like('://webform/') . '%', 'LIKE')
      ->countQuery()
      ->execute()
      ->fetchField();
  }

  // Process all files attached to a given revision during the same batch.
  $limit = variable_get('webform_update_batch_size', 100);
  $files = db_select('file_managed', 'f')
    ->fields('f')
    ->condition('uri', '%' . db_like('://webform/') . '%', 'LIKE')
    ->condition('fid', $sandbox['last_fid_processed'], '>')
    ->orderBy('fid', 'ASC')
    ->range(0, $limit)
    ->execute()
    ->fetchAllAssoc('fid', PDO::FETCH_ASSOC);

  // Determine each submission with which a file is associated.
  if (!empty($files)) {
    foreach ($files as $fid => $file) {
      $file = (object) $file;
      $sids = db_query('SELECT wsd.sid FROM {webform_component} wc INNER JOIN {webform_submitted_data} wsd ON wc.nid = wsd.nid AND wc.type = :file WHERE data = :fid', array(':file' => 'file', ':fid' => $file->fid))->fetchAllAssoc('sid', PDO::FETCH_ASSOC);
      foreach ($sids as $sid => $row) {
        // We use a db_merge() instead of file_usage_add() to prevent problems
        // in the event this update was run twice. No file provided by Webform
        // should ever be in use more than once at this point.
        db_merge('file_usage')
          ->key(array(
            'fid' => $file->fid,
            'type' => 'submission',
            'module' => 'webform',
            'id' => $sid,
          ))
          ->fields(array(
            'count' => 1,
          ))
          ->execute();
      }

      // Update our progress information for the batch update.
      $sandbox['progress']++;
      $sandbox['last_fid_processed'] = $file->fid;
    }
  }

  // If less than limit was processed, the update process is finished.
  if (count($files) < $limit || $sandbox['progress'] == $sandbox['max']) {
    $finished = TRUE;
  }

  // If there's no max value then there's nothing to update and we're finished.
  if (empty($sandbox['max']) || isset($finished)) {
    return t('Webform file entries created in the file_usage table.');
  }
  else {
    // Indicate our current progress to the batch update system.
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Mark files uploaded through Webform that report active usage permanent.
 */
function webform_update_7320() {
  db_query("UPDATE {file_managed} SET status = 1 WHERE fid IN (SELECT fid FROM {file_usage} WHERE module = :module_name)", array(':module_name' => 'webform'));
}

/**
 * Rewrite token replacement system to use D7 tokens.
 *
 * If needed, please download and install the Token module from drupal.org.
 * Otherwise some tokens will not be rendered.
 */
function webform_update_7401(&$sandbox) {
  // Define replacements.
  $patterns = array(
    '%username',
    '%useremail',
    '%uid',
    '%date',
    '%ip_address',
    '%site',
    '%nid',
    '%title',
    '%email_values',
    '%submission_url',
    '%sid',
    '%server[REQUEST_URI]',
    '][', // Used to convert nested arrays of %value and %email.
  );
  $replacements = array(
    '[current-user:name]',
    '[current-user:mail]',
    '[current-user:uid]',
    '[submission:date:long]',
    '[current-user:ip-address]',
    '[site:name]',
    '[node:nid]',
    '[node:title]',
    '[submission:values]',
    '[submission:url]',
    '[submission:sid]',
    '[current-page:url]',
    ':', // Replace "][" with ":" for %value and %email.
  );
  $dpatterns = array(
    '/%get\[([^\]]+)\]/m',
    '/%email\[([^% \n\r\t]+)?\]/m',
    '/%value\[([^% \n\r\t]+)?\]/m',
    '/%profile\[([^\]]+)\]/m',
  );
  $dreplacements = array(
    '[current-page:query:$1]',
    '[submission:values:$1]',
    '[submission:values:$1:nolabel]',
    '[current-user:$1]',
  );

  $limit = variable_get('webform_update_batch_size', 100);
  $processed_count = _webform_update_7401_batch($sandbox, $patterns, $replacements, $dpatterns, $dreplacements, $limit);

  // If less than limit was processed, the update process is finished.
  if ($processed_count < $limit || $sandbox['progress'] == $sandbox['max']) {
    $finished = TRUE;
  }

  // If there's no max value then there's nothing to update and we're finished.
  if (empty($sandbox['max']) || isset($finished)) {
    $message = t('Your existing webforms have been upgraded to use the global Drupal 7 token system.');
    if (!module_exists('token')) {
      $message .= ' <strong>' . t('Please download and install the <a href="http://drupal.org/project/token" target="_blank">Token module</a>. Otherwise some tokens will not be rendered.') . '</strong>';
    }
    return $message;
  }
  else {
    // Indicate our current progress to the batch update system.
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Utility function to update all the locations that use tokens.
 */
function _webform_update_7401_batch(&$sandbox, $patterns, $replacements, $dpatterns, $dreplacements, $limit) {
  // Set up the initial batch process.
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['last_nid_processed'] = -1;
    $sandbox['max'] = db_select('webform')
      ->countQuery()
      ->execute()
      ->fetchField();

    // Update tokens in variables.
    $variables = array(
      'webform_default_subject',
      'webform_default_from_name',
      'webform_default_from_address',
    );
    foreach ($variables as $variable) {
      $value = variable_get($variable, NULL);
      if ($value !== NULL) {
        $value = str_replace($patterns, $replacements, $value);
        $value = preg_replace($dpatterns, $dreplacements, $value);
        variable_set($variable, $value);
      }
    }
  }

  $webforms = db_select('webform', 'w')
    ->fields('w')
    ->condition('nid', $sandbox['last_nid_processed'], '>')
    ->orderBy('nid', 'ASC')
    ->range(0, $limit)
    ->execute()
    ->fetchAllAssoc('nid', PDO::FETCH_ASSOC);

  foreach ($webforms as $nid => $webform) {
    // Update the webform record itself.
    $original = $webform;
    $parts = array(
      'confirmation',
      'redirect_url',
    );
    foreach ($parts as $part) {
      $webform[$part] = str_replace($patterns, $replacements, $webform[$part]);
      $webform[$part] = preg_replace($dpatterns, $dreplacements, $webform[$part]);
    }
    if ($webform != $original) {
      drupal_write_record('webform', $webform, array('nid'));
    }

    // Update tokens in component configurations.
    $result = db_select('webform_component', 'wc', array('fetch' => PDO::FETCH_ASSOC))
      ->fields('wc')
      ->condition('wc.nid', $nid)
      ->execute();
    foreach ($result as $component) {
      $original_extra = $component['extra'];
      $original_value = $component['value'];
      $component['extra'] = unserialize($component['extra']);
      if (isset($component['extra']['description'])) {
        $description = str_replace($patterns, $replacements, $component['extra']['description']);
        $description = preg_replace($dpatterns, $dreplacements, $description);
        $component['extra']['description'] = $description;
      }
      $component['extra'] = serialize($component['extra']);
      $value = str_replace($patterns, $replacements, $component['value']);
      $value = preg_replace($dpatterns, $dreplacements, $value);
      $component['value'] = $value;
      if ($component['extra'] != $original_extra || $component['value'] != $original_value) {
        drupal_write_record('webform_component', $component, array('nid', 'cid'));
      }
    }

    // Update tokens in e-mail configurations.
    $result = db_select('webform_emails', 'we', array('fetch' => PDO::FETCH_ASSOC))
      ->fields('we')
      ->condition('we.nid', $nid)
      ->execute();
    foreach ($result as $email) {
      $parts = array(
        'template',
        'subject',
        'from_name',
      );
      $original = $email;
      foreach ($parts as $part) {
        $email[$part] = str_replace($patterns, $replacements, $email[$part]);
        $email[$part] = preg_replace($dpatterns, $dreplacements, $email[$part]);
      }
      if ($email != $original) {
        drupal_write_record('webform_emails', $email, array('nid', 'eid'));
      }
    }

    // Update the last processed NID.
    $sandbox['last_nid_processed'] = $nid;
    $sandbox['progress']++;
  }
  return count($webforms);
}

/**
 * Add the webform_conditional database table.
 */
function webform_update_7402() {
  $schema['webform_conditional'] = array(
    'description' => 'Holds information about conditional logic.',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'rgid' => array(
        'description' => 'The rule group identifier for this group of rules.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'andor' => array(
        'description' => 'Whether to AND or OR the actions in this group. All actions within the same crid should have the same andor value.',
        'type' => 'varchar',
        'length' => 128,
      ),
      'action' => array(
        'description' => 'The action to be performed on the target. Typically "show" or "hide" for targets of type "component", and "send" for targets of type "email".',
        'type' => 'varchar',
        'length' => 128,
      ),
      'target_type' => array(
        'description' => 'The type of target to be affected. Either "component" or "email". Indicates what type of ID the "target" column contains.',
        'type' => 'varchar',
        'length' => 128,
      ),
      'target' => array(
        'description' => 'The ID of the target to be affected. Typically a component ID.',
        'type' => 'varchar',
        'length' => 128,
      ),
      'weight' => array(
        'description' => 'Determines the position of this conditional compared to others.',
        'type' => 'int',
        'size' => 'small',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('nid', 'rgid'),
  );

  $schema['webform_conditional_rules'] = array(
    'description' => 'Holds information about conditional logic.',
    'fields' => array(
      'nid' => array(
        'description' => 'The node identifier of a webform.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'rgid' => array(
        'description' => 'The rule group identifier for this group of rules.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'rid' => array(
        'description' => 'The rule identifier for this conditional rule.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'source_type' => array(
        'description' => 'The type of source on which the conditional is based. Currently always "component". Indicates what type of ID the "source" column contains.',
        'type' => 'varchar',
        'length' => 128,
      ),
      'source' => array(
        'description' => 'The component ID being used in this condition.',
        'type' => 'int',
        'size' => 'small',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'operator' => array(
        'description' => 'Which operator (equal, contains, starts with, etc.) should be used for this comparison between the source and value?',
        'type' => 'varchar',
        'length' => 128,
      ),
      'value' => array(
        'description' => 'The value to be compared with source.',
        'type' => 'text',
      ),
    ),
    'primary key' => array('nid', 'rgid', 'rid'),
  );

  db_create_table('webform_conditional', $schema['webform_conditional']);
  db_create_table('webform_conditional_rules', $schema['webform_conditional_rules']);
  // Rebuild schema so that webform_update_7403() can use drupal_write_record().
  if (db_table_exists('system') && db_field_exists('system', 'status')) {
    drupal_get_schema(NULL, TRUE);
  }
}

/**
 * Convert per-component conditionals to new more flexible conditional system.
 */
function webform_update_7403(&$sandbox) {
  // Set up the initial batch process.
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['last_nid_processed'] = -1;
    $sandbox['converted_count'] = 0;
    $sandbox['max'] = db_select('webform')
      ->countQuery()
      ->execute()
      ->fetchField();
  }

  $limit = variable_get('webform_update_batch_size', 100);
  $webforms = db_select('webform', 'w')
    ->fields('w')
    ->condition('nid', $sandbox['last_nid_processed'], '>')
    ->orderBy('nid', 'ASC')
    ->range(0, $limit)
    ->execute()
    ->fetchAllAssoc('nid', PDO::FETCH_ASSOC);

  foreach ($webforms as $nid => $webform) {
    // Update tokens in component configurations.
    $result = db_select('webform_component', 'wc', array('fetch' => PDO::FETCH_ASSOC))
      ->fields('wc')
      ->condition('wc.nid', $nid)
      ->execute();
    $rgid = 0;
    foreach ($result as $component) {
      // For each component, check if it has conditional properties that need
      // to be removed and/or migrated. Because these properties may be in any
      // order, copy the original extra array for comparison.
      $component['extra'] = unserialize($component['extra']);
      $original_extra = $component['extra'];

      // Remove conditional properties if present.
      if (isset($component['extra']['conditional_component'])) {
        unset($component['extra']['conditional_component']);
      }
      if (isset($component['extra']['conditional_operator'])) {
        unset($component['extra']['conditional_operator']);
      }
      if (isset($component['extra']['conditional_values'])) {
        unset($component['extra']['conditional_values']);

        // If the component has conditional values specified, that indicates
        // that this component was conditionally shown. Convert it to a new
        // conditional with multiple rules if needed.
        if (strlen(trim($original_extra['conditional_values'])) && !empty($original_extra['conditional_operator']) && !empty($original_extra['conditional_component'])) {
          $conditional_values = explode("\n", $original_extra['conditional_values']);
          $rules = array();
          $rule = array(
            'nid' => $nid,
            'rgid' => $rgid,
            'rid' => NULL,
            'source_type' => 'component',
            'source' => $original_extra['conditional_component'],
            'operator' => 'equal',
            'value' => NULL,
          );
          foreach ($conditional_values as $value) {
            $value = trim($value);
            if ($value) {
              $new_rule = $rule;
              $new_rule['rid'] = count($rules);
              $new_rule['value'] = $value;
              $rules[] = $new_rule;
            }
          }
          if (count($rules)) {
            $conditional = array(
              'nid' => $nid,
              'rgid' => $rgid,
              'andor' => 'or',
              'action' => ($original_extra['conditional_operator'] === '=') ? 'show' : 'hide',
              'target_type' => 'component',
              'target' => $component['cid'],
              'weight' => 0,
            );
            drupal_write_record('webform_conditional', $conditional);
            foreach ($rules as $rule) {
              drupal_write_record('webform_conditional_rules', $rule);
            }
            $sandbox['converted_count']++;
            $rgid++;
          }
        }
      }

      // Update the component with the conditional properties removed.
      if ($component['extra'] != $original_extra) {
        $component['extra'] = serialize($component['extra']);
        drupal_write_record('webform_component', $component, array('nid', 'cid'));
      }
    }

    // Update the last processed NID.
    $sandbox['last_nid_processed'] = $nid;
    $sandbox['progress']++;
  }

  // If less than limit was processed, the update process is finished.
  if (count($webforms) < $limit || $sandbox['progress'] == $sandbox['max']) {
    $finished = TRUE;
  }

  // If there's no max value then there's nothing to update and we're finished.
  if (empty($sandbox['max']) || isset($finished)) {
    return t('@count webforms using conditionals updated to the new conditional system.', array('@count' => $sandbox['converted_count']));
  }
  else {
    // Indicate our current progress to the batch update system.
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Remove files left over from deleted submissions. Such files are now deleted
 * automatically.
 */
function webform_update_7404() {
  module_load_include('inc', 'webform', 'components/file');
  $fids = db_query('SELECT fid FROM {file_usage} WHERE module = \'webform\' AND type = \'submission\' AND NOT id IN(SELECT sid FROM {webform_submissions})')->fetchCol();
  foreach ($fids as $fid) {
    _webform_delete_file(NULL, array($fid));
  }
}

/**
 * Add an "extra" column to the e-mail table for for non-queryable options.
 */
function webform_update_7405() {
  $schema = array(
    'description' => 'A serialized array of additional options for the e-mail configuration, including excluded components and value mapping for the TO and FROM addresses for select lists.',
    'type' => 'text',
    'not null' => FALSE,
    'initial' => '',
  );
  if (!db_field_exists('webform_emails', 'extra')) {
    db_add_field('webform_emails', 'extra', $schema);
  }
}

/**
 * Convert the "webform_use_cookies" setting to "webform_tracking_mode".
 */
function webform_update_7406() {
  // Previously, we only had "strict" and "ip_address" checking. Using cookies
  // meant cookies in addition to IP address.
  $use_cookies = variable_get('webform_use_cookies');
  if (isset($use_cookies)) {
    variable_set('webform_tracking_mode', $use_cookies ? 'strict' : 'ip_address');
    variable_del('webform_use_cookies');
  }
}

/**
 * Remove orphaned conditional rules.
 */
function webform_update_7407() {
  // Delete entire conditions for deleted components that were the target.
  // This query is complicated by database compatibility since we're joining two
  // non-matching columns. See http://drupal.org/node/2026891.
  $result = db_query("SELECT rg.* FROM {webform_conditional} rg LEFT JOIN {webform_component} c ON rg.nid = c.nid AND rg.target_type = 'component' AND rg.target = RTRIM(CAST(c.cid AS CHAR(10))) WHERE c.cid IS NULL");
  foreach ($result as $row) {
    db_delete('webform_conditional')
      ->condition('nid', $row->nid)
      ->condition('rgid', $row->rgid)
      ->execute();
    db_delete('webform_conditional_rules')
      ->condition('nid', $row->nid)
      ->condition('rgid', $row->rgid)
      ->execute();
  }
  // Delete conditional rules for deleted components that were the source.
  $result = db_query("SELECT r.* FROM {webform_conditional_rules} r LEFT JOIN {webform_component} c ON r.nid = c.nid AND r.source_type = 'component' AND r.source = c.cid WHERE c.cid IS NULL");
  foreach ($result as $row) {
    db_delete('webform_conditional_rules')
      ->condition('nid', $row->nid)
      ->condition('rgid', $row->rgid)
      ->condition('rid', $row->rid)
      ->execute();
  }
  // Delete any conditions that no longer have any rules left in them.
  $result = db_query("SELECT rg.* FROM {webform_conditional} rg LEFT JOIN {webform_conditional_rules} r ON rg.nid = r.nid AND rg.rgid = r.rgid WHERE r.rgid IS NULL");
  foreach ($result as $row) {
    db_delete('webform_conditional')
      ->condition('nid', $row->nid)
      ->condition('rgid', $row->rgid)
      ->execute();
  }
}

/**
 * Rename the "mandatory" column to "required".
 */
function webform_update_7408() {
  $spec = array(
    'description' => 'Boolean flag for if this component is required.',
    'type' => 'int',
    'size' => 'tiny',
    'not null' => TRUE,
    'default' => 0,
  );
  db_change_field('webform_component', 'mandatory', 'required', $spec);
}

/**
 * Add progress bar columns to the webform table.
 */
function webform_update_7409() {
  if (!db_field_exists('webform', 'progressbar_bar')) {
    $int_schema = array(
      'type' => 'int',
      'size' => 'tiny',
      'not null' => TRUE,
      'default' => 0,
    );
    $varchar_schema = array(
      'type' => 'varchar',
      'length' => 255,
    );

    $int_schema['description'] = 'Boolean value indicating if the bar should be shown as part of the progress bar.';
    db_add_field('webform', 'progressbar_bar', $int_schema);

    $int_schema['description'] = 'Boolean value indicating if the page number should be shown as part of the progress bar.';
    db_add_field('webform', 'progressbar_page_number', $int_schema);

    $int_schema['description'] = 'Boolean value indicating if the percentage complete should be shown as part of the progress bar.';
    db_add_field('webform', 'progressbar_percent', $int_schema);

    $int_schema['description'] = 'Boolean value indicating if the pagebreak labels should be included as part of the progress bar.';
    db_add_field('webform', 'progressbar_pagebreak_labels', $int_schema);

    $int_schema['description'] = 'Boolean value indicating if the confirmation page should count as a page in the progress bar.';
    db_add_field('webform', 'progressbar_include_confirmation', $int_schema);

    $varchar_schema['description'] = 'Label for the first page of the progress bar.';
    db_add_field('webform', 'progressbar_label_first', $varchar_schema);

    $varchar_schema['description'] = 'Label for the last page of the progress bar.';
    db_add_field('webform', 'progressbar_label_confirmation', $varchar_schema);

    return t('New webform columns added.');
  }
}

/**
 * Remove the "teaser" column from the "webform" table.
 */
function webform_update_7410() {
  if (db_field_exists('webform', 'teaser')) {
    db_drop_field('webform', 'teaser');
    return t('Removed "teaser" column. All forms that had the "Show form in teaser" option disabled will now show forms in their teasers. Use view modes to hide the form if desired.');
  }
}

/**
 * Remove [submission:values:x] token use of :nolabel and add :withlabel.
 */
function webform_update_7411(&$sandbox) {
  // Define replacements.
  $patterns = array();
  $replacements = array();
  $dpatterns = array(
    '/\[submission:values(:(?!nolabel)[a-z_]+)+\]/m',
    '/\[submission:values(:([a-z_:]+))?:nolabel\]/m',
  );
  $dreplacements = array(
    '[submission:values$1:withlabel]',
    '[submission:values$1]',
  );

  $limit = variable_get('webform_update_batch_size', 100);
  $processed_count = _webform_update_7401_batch($sandbox, $patterns, $replacements, $dpatterns, $dreplacements, $limit);

  // If less than limit was processed, the update process is finished.
  if ($processed_count < $limit || $sandbox['progress'] == $sandbox['max']) {
    $finished = TRUE;
  }

  // If there's no max value then there's nothing to update and we're finished.
  if (empty($sandbox['max']) || isset($finished)) {
    return t('Replaced tokens using [submission:values:x] with [submission:values:x:withlabel].');
  }
  else {
    // Indicate our current progress to the batch update system.
    $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max'];
  }
}

/**
 * Split webform_node_types as content type specific.
 */
function webform_update_7412() {
  $types = variable_get('webform_node_types', array('webform'));
  foreach ($types as $type) {
    variable_set('webform_node_' . $type, TRUE);
  }
  variable_del('webform_node_types');
}
