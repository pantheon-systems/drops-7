<?php

/**
 * @file
 * Elysia cron primary module file.
 */

require_once 'elysia_cron_scheduler.inc';
require_once 'elysia_cron.admin.inc';
require_once 'elysia_cron.ctools.inc';

/**
 * Implements hook_menu().
 */
function elysia_cron_menu() {
  $items['admin/config/system/cron'] = array(
    'title' => 'Cron Settings',
    'description' => 'View and manage cron table',
    'page callback' => 'elysia_cron_admin_page',
    'access callback' => 'elysia_cron_access',
    'access arguments' => array('view elysia_cron'),
  );
  $items['admin/config/system/cron/status'] = array(
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'title' => 'Status',
    'weight' => 1,
  );
  $items['admin/config/system/cron/settings'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('elysia_cron_settings_form'),
    'access callback' => 'elysia_cron_access',
    'access arguments' => array('administer elysia_cron'),
    'weight' => 2,
  );
  $items['admin/config/system/cron/maintenance'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Maintenance',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('elysia_cron_reset_statistics_form'),
    'access callback' => 'elysia_cron_access',
    'access arguments' => array('administer elysia_cron'),
    'weight' => 3,
  );
  $items['admin/config/system/cron/execute/%'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'elysia_cron_execute_page',
    'page arguments' => array(5),
    'access callback' => 'elysia_cron_access',
    'access arguments' => array('execute elysia_cron'),
  );
  $items['admin/build/cron/ping'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'elysia_cron_ping_page',
    'access callback' => TRUE,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function elysia_cron_menu_alter(&$items) {
  // Override default cron page.
  $items['admin/config/system/cron'] = array(
    'title' => 'Cron Settings',
    'description' => 'View and manage cron table',
    'page callback' => 'elysia_cron_admin_page',
    'access callback' => 'elysia_cron_access',
    'access arguments' => array('view elysia_cron'),
    'file' => NULL,
  ) + $items['admin/config/system/cron'];
}

/**
 * Check access to operation inside elysia cron module.
 *
 * Permission have nested structure, for example: "administer elysia_cron" allow
 * to do anything: view, execute and configure cron jobs.
 *
 * @param string $perm
 *   Permission name.
 *
 * @return bool
 *   Access granted or not.
 */
function elysia_cron_access($perm) {
  $access = FALSE;

  switch ($perm) {
    case 'administer elysia_cron':
      $access = user_access($perm);
      break;

    case 'execute elysia_cron':
      $access = user_access($perm) || user_access('administer elysia_cron');
      break;

    case 'view elysia_cron';
      $access = user_access($perm) || user_access('execute elysia_cron') || user_access('administer elysia_cron');
  }

  return $access;
}

/**
 * Implements hook_permission().
 */
function elysia_cron_permission() {
  return array(
    'administer elysia_cron' => array(
      'title' => t('Administer elysia cron'),
      'description' => t('Perform changes to cron jobs timings, disable cron or single jobs and access cron execution statistics'),
      'restrict access' => TRUE,  
    ),
    'execute elysia_cron' => array(
      'title' => t('Execute elysia cron jobs'),
      'description' => t('Allow users to view statistics, execution status and do manually execute cron jobs'),
    ),
    'view elysia_cron' => array(
      'title' => t('View elysia cron stats'),
      'description' => t('Allows users to view statistics and execution status of cron jobs'),
    ),
  );
}

/**
 * Implements hook_exit().
 */
function elysia_cron_exit() {
  global $_elysia_cron_exit_phase;
  $_elysia_cron_exit_phase = TRUE;
}

/**
 * Implements hook_cron().
 *
 * Hook cron is invoked only by standard drupal cron.
 * It's used to replace drupal cron.
 */
function elysia_cron_cron() {
  global $_elysia_cron_exit_phase, $_elysia_cron_drush;

  // If cron has been executed via "drush core-cron" or any other custom drush
  // command then we run internal cron handler which is designed to handle
  // cron executions from drush.
  if (function_exists('elysia_cron_drush_detect') && elysia_cron_drush_detect()) {
    elysia_cron_drush_invoke();
  }

  // First cron run is executed in standard drupal way.
  // This is to enable the use of install profiles.
  if (variable_get('cron_last', 0) <= variable_get('install_time', 0)) {
    return;
  }
  // If the path is 'admin/*', or if the user is not anonymous,
  // this is a manual cron run (probably by admin/logs/status),
  // but not if we are in the exit phase (= this a "poormanscron" run).
  $manual_run = empty($_elysia_cron_exit_phase) && ((arg(0) == 'admin') || !empty($GLOBALS['user']->uid));

  $result = elysia_cron_run($manual_run);

  if ($manual_run) {
    if ($result) {
      elysia_cron_message('Cron ran successfully');
    }
    else {
      elysia_cron_message('Cron run failed, disabled or nothing to do');
    }
    // In manual execution it's better to set cron_last variable in standard way
    // (so the user sees the execution time updates).
    // This invalidates variable cache, but it's a manual execution,
    // it should be not a great performance problem.
    if (empty($_elysia_cron_drush)) {
      variable_set('cron_last', time());
    }

    drupal_goto('admin/reports/status');
  }

  // If we are in "poormanscron" mode it's better to force setting of cron_last.
  // This invalidates variable cache, but is needed for right execution check.
  // @see system_run_automated_cron() in system.module
  if (!empty($_elysia_cron_exit_phase)) {
    variable_set('cron_last', time());
  }

  exit();
}

/**
 * Implements hook_cron().
 *
 * I use help section for admin/build/modules page to check if elysia_cron
 * is the module with the smallest weight.
 * If it's not i'll set it and print a message.
 */
function elysia_cron_help($section, $arg = FALSE) {
  if ($section == 'admin/modules') {
    $query = db_select('system', 's');
    $query->addExpression('MIN(weight)');
    $min = $query->condition('s.name', 'elysia_cron', '!=')
      ->execute()
      ->fetchField();

    $weight = db_select('system', 's')
      ->fields('s', array('weight'))
      ->condition('s.name', 'elysia_cron')
      ->execute()
      ->fetchField();

    if ($min <= $weight) {
      elysia_cron_message('Elysia cron module is not the module with the smallest weight (and it must be). Updating weight...');
      db_update('system')
        ->fields(array('weight' => $min - 1))
        ->condition('name', 'elysia_cron')
        ->execute();
    }
  }
}

// Variables managed by _ec_variable method,
// because are setted during cron execution handling
// (with standard variable_set this will invalidate variable
// cache in EVERY cron clock).
$GLOBALS['_ec_variables_allowed'] = array(
  'elysia_cron_semaphore',
  'elysia_cron_last_run',
  'elysia_cron_last_channel',
  'cron_semaphore',
  'cron_last',
);

/**
 * Initialise global variables.
 */
function _ec_variable_init() {
  global $_ec_variables, $_ec_variables_allowed;
  $_ec_variables = array();
  $_ec_variables = array_map('unserialize', db_query("SELECT name, value FROM {variable} where name like '" . implode("' or name like '", $_ec_variables_allowed) . "'")->fetchAllKeyed());
}

/**
 * A substitute for variable_get to avoid cache management.
 *
 * Use ONLY for variables set during cron execution:
 * elysia_cron_semaphore, elysia_cron_last_run, elysia_cron_last_channel,
 * cron_semaphore, cron_last
 * WARN_UPGRADE.
 */
function _ec_variable_get($name, $default) {
  global $_ec_variables, $_ec_variables_allowed;
  if (!in_array($name, $_ec_variables_allowed)) {
    elysia_cron_error('Wrong variable passed to _ec_variable_get: !var', array('!var' => $name), TRUE);
    return variable_get($name, $default);
  }

  if (!is_array($_ec_variables)) {
    _ec_variable_init();
  }

  // If there is a $GLOBALS['original_conf'] = $conf; at the end of settings.php
  // i consider it.
  global $_original_conf;

  if (isset($_original_conf[$name])) {
    return $_original_conf[$name];
  }
  if (isset($_ec_variables[$name])) {
    return $_ec_variables[$name];
  }

  return $default;
}

/**
 * A substitute for variable_set to avoid cache management.
 *
 * Use ONLY for variables set during cron execution:
 * elysia_cron_semaphore, elysia_cron_last_run, elysia_cron_last_channel,
 * cron_semaphore, cron_last.
 * WARN_UPGRADE.
 */
function _ec_variable_set($name, $value) {
  global $_ec_variables, $_ec_variables_allowed;
  if (!in_array($name, $_ec_variables_allowed)) {
    elysia_cron_error('Wrong variable passed to _ec_variable_set: !var', array('!var' => $name), TRUE);
    variable_set($name, $value);
  }

  if (!is_array($_ec_variables)) {
    _ec_variable_init();
  }

  db_merge('variable')->key(array('name' => $name))->fields(array('value' => serialize($value)))->execute();

  $_ec_variables[$name] = $value;
}

/**
 * A substitute for variable_del to avoid cache management.
 *
 * Use ONLY for variables set during cron execution:
 * elysia_cron_semaphore, elysia_cron_last_run, elysia_cron_last_channel,
 * cron_semaphore, cron_last
 * WARN_UPGRADE.
 */
function _ec_variable_del($name) {
  global $_ec_variables, $_ec_variables_allowed;
  if (!in_array($name, $_ec_variables_allowed)) {
    elysia_cron_error('Wrong variable passed to _ec_variable_del: !var', array('!var' => $name), TRUE);
    variable_del($name);
    return;
  }

  if (!is_array($_ec_variables)) {
    _ec_variable_init();
  }

  db_delete('variable')->condition('name', $name)->execute();

  unset($_ec_variables[$name]);
}

function _ec_get_name($name) {
  $maxlen = 120;
  if (strlen($name) < $maxlen) {
    return $name;
  }
  $border = ($maxlen - 32) / 2;
  return substr($name, 0, $border) . md5($name) . substr($name, -$border);
}

function elysia_cron_set($name, $channel = FALSE, $values = array()) {
  if ($channel) {
    $name = ':' . $name;
  }

  db_merge('elysia_cron')->key(array('name' => $name))->fields($values)->execute();

  global $_elysia_cron_db_cache;

  unset($_elysia_cron_db_cache[$name]);
}

function elysia_cron_get($name, $channel = FALSE, $key = FALSE, $default = FALSE, $refresh = FALSE) {
  global $_elysia_cron_db_cache;
  static $elysia_cron_defaults;

  if (!isset($elysia_cron_defaults)) {
    $elysia_cron_defaults = function_exists('elysia_cron_get_ctools_defaults') ? elysia_cron_get_ctools_defaults() : array();
  }

  if ($channel) {
    $name = ':' . $name;
  }

  if ($refresh || !isset($_elysia_cron_db_cache[$name])) {
    $_elysia_cron_db_cache[$name] = db_select('elysia_cron', 'ec')
      ->fields('ec', _elysia_cron_columns())
      ->condition('name', $name)
      ->execute()
      ->fetchAssoc();

    if (!$_elysia_cron_db_cache[$name] && isset($elysia_cron_defaults[$name])) {
      $_elysia_cron_db_cache[$name] = (array) $elysia_cron_defaults[$name];
    }
    elseif ($_elysia_cron_db_cache[$name] && isset($elysia_cron_defaults[$name])) {
      foreach ($elysia_cron_defaults[$name] as $k => $v) {
        if (!isset($_elysia_cron_db_cache[$name][$k]) || is_null($_elysia_cron_db_cache[$name][$k])) {
          $_elysia_cron_db_cache[$name][$k] = $v;
        }
      }
    }
  }

  return !$_elysia_cron_db_cache[$name] || !isset($_elysia_cron_db_cache[$name][$key]) || is_null($_elysia_cron_db_cache[$name][$key]) ? $default : $_elysia_cron_db_cache[$name][$key];
}

/**
 * Get status of specified channel.
 *
 * @param string $channel
 *   Channel name.
 * @param bool $default
 *   Default value for channel status.
 * @param bool $refresh
 *   If TRUE - fresh status will be get from database.
 *
 * @return bool
 *   Channel status.
 */
function elysia_cron_is_channel_disabled($channel, $default = FALSE, $refresh = FALSE) {
  // May be overridden by a static conf.
  if (isset($GLOBALS['conf'][$n = 'ecc_' . _ec_get_name($channel) . '_d'])) {
    return $GLOBALS['conf'][$n];
  }

  return elysia_cron_get($channel, TRUE, 'disable', $default, $refresh);
}

/**
 * Update channel status.
 *
 * @param string $channel
 *   Channel name.
 * @param bool $value
 *   New channel status:
 *   TRUE - enabled
 *   FALSE - disabled.
 */
function elysia_cron_set_channel_disabled($channel, $value) {
  elysia_cron_set($channel, TRUE, array('disable' => $value ? 1 : 0));
}

/**
 * Reset channel status to default (disabled).
 *
 * @param string $channel
 *   Channel name.
 */
function elysia_cron_reset_channel_disabled($channel) {
  elysia_cron_set($channel, TRUE, array('disable' => 0));
}

/**
 * Get channel's rule.
 *
 * @param string $channel
 *   Channel name.
 * @param string $default
 *   Default rule.
 * @param bool $refresh
 *   If TRUE - fresh status will be get from database.
 *
 * @return string
 *   Formatted rule for specified channel.
 */
function elysia_cron_get_channel_rule($channel, $default = '', $refresh = FALSE) {
  // May be overridden by a static conf.
  if (isset($GLOBALS['conf'][$n = 'ecc_' . _ec_get_name($channel) . '_rul'])) {
    return $GLOBALS['conf'][$n];
  }

  return elysia_cron_get($channel, TRUE, 'rule', $default, $refresh);
}

/**
 * Set new rule for channel.
 *
 * @param string $channel
 *   Channel name.
 * @param string $rule
 *   Crontab formatted rule.
 */
function elysia_cron_set_channel_rule($channel, $rule) {
  elysia_cron_set($channel, TRUE, array('rule' => $rule));
}

/**
 * Reset channel's rule to default.
 *
 * @param string $channel
 *   Channel name.
 */
function elysia_cron_reset_channel_rule($channel) {
  elysia_cron_set($channel, TRUE, array('rule' => NULL));
}

/**
 * Check if channel is running now.
 *
 * @param string $channel
 *   Channel name.
 * @param int $default
 *   Default value.
 * @param bool $refresh
 *   If TRUE - fresh status will be get from database.
 *
 * @return int
 *   Timestamp from beginning of running or zero.
 */
function elysia_cron_is_channel_running($channel, $default = 0, $refresh = FALSE) {
  return elysia_cron_get($channel, TRUE, 'running', $default, $refresh);
}

/**
 * Updated channel running value.
 *
 * @param string $channel
 *   Channel name.
 * @param int $value
 *   New running value.
 */
function elysia_cron_set_channel_running($channel, $value) {
  elysia_cron_set($channel, TRUE, array('running' => $value));
}

/**
 * Get channel's last run value.
 *
 * @param string $channel
 *   Channel name.
 * @param int $default
 *   Default value.
 * @param bool $refresh
 *   If TRUE - fresh status will be get from database.
 *
 * @return int
 *   Last run timestamp or zero.
 *
 * @todo Not used, to delete?
 */
function elysia_cron_get_channel_last_run($channel, $default = 0, $refresh = FALSE) {
  return elysia_cron_get($channel, TRUE, 'last_run', $default, $refresh);
}

/**
 * Set channel's last run value.
 *
 * @param string $channel
 *   Channel name.
 * @param int $value
 *   New last run timestamp.
 *
 * @todo Not used, to delete?
 */
function elysia_cron_set_channel_last_run($channel, $value) {
  elysia_cron_set($channel, TRUE, array('last_run' => $value));
}

/**
 * Get channel's last aborted value.
 *
 * @param string $channel
 *   Channel name.
 * @param int $default
 *   Default value.
 * @param bool $refresh
 *   If TRUE - fresh status will be get from database.
 *
 * @return int
 *   Last aborted timestamp or zero.
 *
 * @todo Not used, to delete?
 */
function elysia_cron_get_channel_last_aborted($channel, $default = 0, $refresh = FALSE) {
  return elysia_cron_get($channel, TRUE, 'last_aborted', $default, $refresh);
}

/**
 * Set channel's last aborted value.
 *
 * @param string $channel
 *   Channel name.
 * @param int $value
 *   New last aborted timestamp.
 *
 * @todo Not used, to delete?
 */
function elysia_cron_set_channel_last_aborted($channel, $value) {
  elysia_cron_set($channel, TRUE, array('last_aborted' => $value ? 1 : 0));
}

/**
 * Get channel's about count.
 *
 * @param string $channel
 *   Channel name.
 * @param int $default
 *   Default value.
 * @param bool $refresh
 *   If TRUE - fresh status will be get from database.
 *
 * @return int
 *   Abort count for specified channel.
 */
function elysia_cron_get_channel_abort_count($channel, $default = 0, $refresh = FALSE) {
  return elysia_cron_get($channel, TRUE, 'abort_count', $default, $refresh);
}

/**
 * Set channel's abort count.
 *
 * @param string $channel
 *   Channel name.
 * @param int $value
 *   New abort count.
 *
 * @todo Not used, to delete?
 */
function elysia_cron_set_channel_abort_count($channel, $value) {
  elysia_cron_set($channel, TRUE, array('abort_count' => $value));
}

/**
 * Get channel's last about function.
 *
 * @param string $channel
 *   Channel name.
 * @param string $default
 *   Default value.
 * @param bool $refresh
 *   If TRUE - fresh status will be get from database.
 *
 * @return string
 *   Last abort function or empty string.
 *
 * @todo Not used, to delete?
 */
function elysia_cron_get_channel_last_abort_function($channel, $default = '', $refresh = FALSE) {
  return elysia_cron_get($channel, TRUE, 'last_abort_function', $default, $refresh);
}

/**
 * Set channel's last abort function.
 *
 * @param string $channel
 *   Channel name.
 * @param string $value
 *   Last abort function name.
 *
 * @todo Not used, to delete?
 */
function elysia_cron_set_channel_last_abort_function($channel, $value) {
  elysia_cron_set($channel, TRUE, array('last_abort_function' => $value));
}

/**
 * Grab statistics by channel.
 *
 * @param string $channel
 *   Channel name.
 * @param bool $refresh
 *   If TRUE - fresh status will be get from database.
 *
 * @return array
 *   Statistics for specified channel.
 */
function elysia_cron_get_channel_stats($channel, $refresh = FALSE) {
  return array(
    'last_run' => elysia_cron_get($channel, TRUE, 'last_run', 0, $refresh),
    'last_execution_time' => elysia_cron_get($channel, TRUE, 'last_execution_time', 0, $refresh),
    'execution_count' => elysia_cron_get($channel, TRUE, 'execution_count', 0, $refresh),
    'avg_execution_time' => elysia_cron_get($channel, TRUE, 'avg_execution_time', 0, $refresh),
    'max_execution_time' => elysia_cron_get($channel, TRUE, 'max_execution_time', 0, $refresh),
    'last_shutdown_time' => elysia_cron_get($channel, TRUE, 'last_shutdown_time', 0, $refresh),
    'last_aborted' => elysia_cron_get($channel, TRUE, 'last_aborted', 0, $refresh),
    'abort_count' => elysia_cron_get($channel, TRUE, 'abort_count', 0, $refresh),
    'last_abort_function' => elysia_cron_get($channel, TRUE, 'last_abort_function', 0, ''),
  );
}

/**
 * Update channel's stats.
 *
 * @param string $channel
 *   Channel name.
 * @param array $data
 *   Associative array of values.
 */
function elysia_cron_set_channel_stats($channel, array $data = array()) {
  elysia_cron_set($channel, TRUE, $data);
}

/**
 * Get formatted crontab rule for specified job.
 *
 * @param string $job
 *   Job name.
 * @param string $default
 *   Default rule.
 * @param bool $refresh
 *   If TRUE - fresh status will be get from database.
 *
 * @return string
 *   Formatted job rule.
 */
function elysia_cron_get_job_rule($job, $default = '', $refresh = FALSE) {
  // May be overridden by a static conf.
  if (isset($GLOBALS['conf'][$n = 'ec_' . _ec_get_name($job) . '_rul'])) {
    return $GLOBALS['conf'][$n];
  }

  return elysia_cron_get($job, FALSE, 'rule', $default, $refresh);
}

/**
 * Set formatted crontab rule for specified job.
 *
 * @param string $job
 *   Job name.
 * @param string $value
 *   New crontab rule for job.
 */
function elysia_cron_set_job_rule($job, $value) {
  elysia_cron_set($job, FALSE, array('rule' => $value));
}

/**
 * Reset crontab job rule to default.
 *
 * @param string $job
 *   Job name.
 */
function elysia_cron_reset_job_rule($job) {
  elysia_cron_set($job, FALSE, array('rule' => NULL));
}

/**
 * Get weight of specified job.
 *
 * @param string $job
 *   Job name.
 * @param string $default
 *   Default weight.
 * @param bool $refresh
 *   If TRUE - fresh status will be get from database.
 *
 * @return string
 *   Job weight or empty string.
 */
function elysia_cron_get_job_weight($job, $default = '', $refresh = FALSE) {
  // May be overridden by a static conf.
  if (isset($GLOBALS['conf'][$n = 'ec_' . _ec_get_name($job) . '_w'])) {
    return $GLOBALS['conf'][$n];
  }
  return elysia_cron_get($job, FALSE, 'weight', $default, $refresh);
}

/**
 * Set weight specified job.
 *
 * @param string $job
 *   Job name.
 * @param string $value
 *   New weight for job.
 */
function elysia_cron_set_job_weight($job, $value) {
  elysia_cron_set($job, FALSE, array('weight' => $value));
}

/**
 * Reset job weight to default.
 *
 * @param string $job
 *   Job name.
 */
function elysia_cron_reset_job_weight($job) {
  elysia_cron_set($job, FALSE, array('weight' => NULL));
}

function elysia_cron_is_job_disabled($job, $default = FALSE, $refresh = FALSE) {
  // May be overridden by a static conf.
  if (isset($GLOBALS['conf'][$n = 'ec_' . _ec_get_name($job) . '_d'])) {
    return $GLOBALS['conf'][$n];
  }
  return elysia_cron_get($job, FALSE, 'disable', $default, $refresh);
}

function elysia_cron_set_job_disabled($job, $value) {
  elysia_cron_set($job, FALSE, array('disable' => $value ? 1 : 0));
}

function elysia_cron_reset_job_disabled($job) {
  elysia_cron_set($job, FALSE, array('disable' => NULL));
}

function elysia_cron_get_job_channel($job, $default = '', $refresh = FALSE) {
  // May be overridden by a static conf.
  if (isset($GLOBALS['conf'][$n = 'ec_' . _ec_get_name($job) . '_c'])) {
    $c = $GLOBALS['conf'][$n];
  }
  else {
    // In this place, 'context' means 'channel'.
    $c = elysia_cron_get($job, FALSE, 'context', $default, $refresh);
  }
  return !$c ? $default : $c;
}

function elysia_cron_set_job_channel($job, $value) {
  // In this place, 'context' means 'channel'.
  elysia_cron_set($job, FALSE, array('context' => $value));
}

function elysia_cron_reset_job_channel($job) {
  // In this place, 'context' means 'channel'.
  elysia_cron_set($job, FALSE, array('context' => NULL));
}

function elysia_cron_is_job_running($job, $default = 0, $refresh = FALSE) {
  return elysia_cron_get($job, FALSE, 'running', $default, $refresh);
}

function elysia_cron_set_job_running($job, $value) {
  elysia_cron_set($job, FALSE, array('running' => $value));
}

function elysia_cron_get_job_last_run($job, $default = 0, $refresh = FALSE) {
  return elysia_cron_get($job, FALSE, 'last_run', $default, $refresh);
}

function elysia_cron_set_job_last_run($job, $value) {
  elysia_cron_set($job, FALSE, array('last_run' => $value));
}

function elysia_cron_get_job_stats($job, $refresh = FALSE) {
  return array(
    'last_run' => elysia_cron_get($job, FALSE, 'last_run', 0, $refresh),
    'last_execution_time' => elysia_cron_get($job, FALSE, 'last_execution_time', 0, $refresh),
    'execution_count' => elysia_cron_get($job, FALSE, 'execution_count', 0, $refresh),
    'avg_execution_time' => elysia_cron_get($job, FALSE, 'avg_execution_time', 0, $refresh),
    'max_execution_time' => elysia_cron_get($job, FALSE, 'max_execution_time', 0, $refresh),
  );
}

function elysia_cron_set_job_stats(
  $job,
  $last_run = -1,
  $last_execution_time = -1,
  $execution_count = -1,
  $avg_execution_time = -1,
  $max_execution_time = -1,
  $data = array()
) {
  if ($last_run != -1) {
    $data['last_run'] = $last_run;
  }
  if ($last_execution_time != -1) {
    $data['last_execution_time'] = $last_execution_time;
  }
  if ($execution_count != -1) {
    $data['execution_count'] = $execution_count;
  }
  if ($avg_execution_time != -1) {
    $data['avg_execution_time'] = $avg_execution_time;
  }
  if ($max_execution_time != -1) {
    $data['max_execution_time'] = $max_execution_time;
  }
  elysia_cron_set($job, FALSE, $data);
}

function elysia_cron_last_channel() {
  return _ec_variable_get('elysia_cron_last_channel', '');
}

function elysia_cron_set_last_channel($channel) {
  _ec_variable_set('elysia_cron_last_channel', $channel);
}

function elysia_cron_reset_stats() {
  global $_elysia_cron_settings, $_elysia_cron_settings_by_channel;
  elysia_cron_initialize();

  foreach ($_elysia_cron_settings as $job => $conf) {
    elysia_cron_set_job_stats($job, 0, 0, 0, 0, 0);
  }

  $channel_reset_data = array(
    'last_run' => 0,
    'last_execution_time' => 0,
    'execution_count' => 0,
    'avg_execution_time' => 0,
    'max_execution_time' => 0,
    'last_shutdown_time' => 0,
    'last_aborted' => 0,
    'abort_count' => 0,
    'last_abort_function' => 0,
  );
  foreach ($_elysia_cron_settings_by_channel as $channel => $conf) {
    elysia_cron_set_channel_stats($channel, $channel_reset_data);
  }
}

/*******************************************************************************
 * INTERNAL
 *
 * WARN: Below this point the word "context" should be avoided (use channel)
 *   Disabled should always be referenced as "disabled" (in db is "disable" for
 *   compatibility with Ctools )
 *******************************************************************************/

/**
 * Sends a standard message to user.
 *
 * Drush see it.
 */
function elysia_cron_message($message, $vars = array()) {
  global $_elysia_cron_drush;
  if (empty($_elysia_cron_drush)) {
    drupal_set_message(t($message, $vars));
  }
  else {
    drush_log(strip_tags(dt($message, $vars)), 'ok');
  }
}

/**
 * Send an error message to user (and log also an error).
 *
 * Drush see it (even if $skip_user_message)
 */
function elysia_cron_error($message, $vars = array(), $skip_user_message = FALSE) {
  global $_elysia_cron_drush;
  if (empty($_elysia_cron_drush) && !$skip_user_message) {
    drupal_set_message(t($message, $vars), 'error');
  }
  /* @todo remove following code if not necessary.
  if (!empty($_elysia_cron_drush)) {
  drush_log(strip_tags(dt($message, $vars)), "error");
  }*/
  watchdog('cron', $message, $vars, WATCHDOG_ERROR);
}

/**
 * Log a debug in watchdog (do not print an user message).
 *
 * Drush see it in verbose mode.
 */
function elysia_cron_debug($message, $vars = array(), $type = WATCHDOG_NOTICE) {
  global $_elysia_cron_drush;
  if ($type < WATCHDOG_NOTICE || variable_get('elysia_cron_debug_messages', 0)) {
    watchdog('cron', $message, $vars, $type);
  }
  if (!empty($_elysia_cron_drush) && $_elysia_cron_drush >= 2 && ($type >= WATCHDOG_NOTICE || !drush_get_option("verbose", FALSE))) {
    if ($type >= WATCHDOG_NOTICE) {
      drush_print(strip_tags(dt($message, $vars)));
    }
    else {
      drush_log(strip_tags(dt($message, $vars)), $type == WATCHDOG_ERROR ? "error" : (($type == WATCHDOG_ERROR ? "warning" : "notice")));
    }
  }
}

/**
 * Log a warning (do not print an user message).
 *
 * Drush see it in verbose mode.
 */
function elysia_cron_warning($message, $vars = array()) {
  elysia_cron_debug($message, $vars, WATCHDOG_WARNING);
}

function elysia_cron_decode_script($text, $apply = TRUE) {
  global $_elysia_cron_settings;

  $lines = explode(PHP_EOL, $text);
  $lastcomment = '';
  $errors = array();
  foreach ($lines as $line) {
    $line = trim($line);
    if (!empty($line)) {
      if ($line{0} == '#') {
        $lastcomment = trim(substr($line, 1));

      }
      elseif (preg_match('/^(-[ ]*|)([0-9*,\/-]+[ ]+[0-9*,\/-]+[ ]+[0-9*,\/-]+[ ]+[0-9*,\/-]+[ ]+[0-9*,\/-]+)[ ]+((?:ctx|ch):([a-zA-Z0-9_-]+)[ ]+|)([^(:]+)(\(.*\);|)$/', $line, $r)) {
        $c = array(
          'disabled' => !empty($r[1]),
          'rule' => $r[2],
          'description' => $lastcomment,
          'channel' => $r[4] ? $r[4] : 'default',
        );
        $lastcomment = '';
        if (empty($r[6])) {
          if (!isset($_elysia_cron_settings[$r[5]])) {
            // Referring a module function that not exists.
            $errors[] = $line;
            continue;
          }
          $name = $r[5];
        }
        else {
          // Custom expression, generate a unique name.
          $postfix = '';
          while (isset($_elysia_cron_settings[$r[5] . $postfix])) {
            $postfix = ($postfix ? $postfix : 0) + 1;
          }
          $name = $r[5] . $postfix;
          $c['expression'] = $r[5] . $r[6];
        }
        if ($apply) {
          $_elysia_cron_settings[$name] = isset($_elysia_cron_settings[$name]) ? array_merge($_elysia_cron_settings[$name], $c) : $c;
        }

      }
      else {
        $errors[] = $line;
      }
    }
    else {
      $lastcomment = '';
    }
  }

  return count($errors) ? $errors : FALSE;
}

/**
 * Fetch information about cron jobs from modules.
 *
 * @return array
 *   Array with jobs information.
 */
function elysia_cron_module_jobs() {
  static $jobs;

  if (!isset($jobs)) {
    $jobs = array();
    foreach (module_implements('cron') as $module) {
      if ($module != 'elysia_cron') {
        $jobs[$module . '_cron'] = array(
          'module' => $module,
          'callback' => $module . '_cron',
          'arguments' => array(),
        );
      }
    }

    foreach (module_implements('cronapi') as $module) {
      $function = $module . '_cronapi';

      if (function_exists($function)) {
        $job_list = $function('list');

        if (is_array($job_list)) {
          foreach ($job_list as $job => $data) {
            if (is_array($data)) {
              $jobs[$job] = $data;
            }
            else {
              // Compatibility with v1.x settings.
              $jobs[$job] = array(
                'description' => $data,
                'rule' => ($rule = $function('rule', $job)) ? $rule : FALSE,
                'weight' => ($weight = $function('weight', $job)) ? $weight : 0,
              );
            }

            $jobs[$job] = $jobs[$job] + array(
              'module' => $module,
              'callback' => $job,
              'arguments' => array(),
            );
          }
        }
      }
    }

    if (function_exists('drupal_alter')) {
      drupal_alter('cron', $jobs);
    }
  }

  return $jobs;
}

function elysia_cron_initialize($skipscript = FALSE) {
  global $_elysia_cron_settings, $_elysia_cron_settings_by_channel;

  if (empty($_elysia_cron_settings)) {

    $_elysia_cron_settings = array();
    $_elysia_cron_settings_by_channel = array();

    foreach (elysia_cron_module_jobs() as $job => $jobpars) {
      $channel = elysia_cron_get_job_channel($job, 'default');

      $defrule = !empty($jobpars['rule']) ? $jobpars['rule'] : elysia_cron_get_channel_rule($channel);
      if (!$defrule) {
        $defrule = variable_get('elysia_cron_default_rule', '0 * * * *');
      }

      $defweight = !empty($jobpars['weight']) ? $jobpars['weight'] : 0;
      if (!is_numeric($defweight)) {
        $defweight = 0;
      }

      $_elysia_cron_settings[$job] = array(
        'key' => $job,
        'channel' => $channel,
        'rule' => elysia_cron_get_job_rule($job, $defrule),
        'default_rule' => $defrule,
        'weight' => elysia_cron_get_job_weight($job, $defweight),
        'default_weight' => $defweight,
        'disabled' => elysia_cron_is_job_disabled($job),
        'running' => elysia_cron_is_job_running($job),
      ) + $jobpars;
    }
    if (!$skipscript) {
      $script = variable_get('elysia_cron_script', FALSE);
      if ($script) {
        elysia_cron_decode_script($script);
      }
    }

    uasort($_elysia_cron_settings, '_elysia_cron_sort');
    foreach ($_elysia_cron_settings as $job => &$conf) {
      $stats = elysia_cron_get_job_stats($job);
      foreach ($stats as $sk => $sv) {
        $conf[$sk] = $sv;
      }
      $_elysia_cron_settings_by_channel[$conf['channel']][$job] = &$_elysia_cron_settings[$job];
    }

    foreach ($_elysia_cron_settings_by_channel as $channel => $data) {
      uasort($_elysia_cron_settings_by_channel[$channel], '_elysia_cron_sort');
      $_elysia_cron_settings_by_channel[$channel]['#data'] = elysia_cron_get_channel_stats($channel);
      $_elysia_cron_settings_by_channel[$channel]['#data']['disabled'] = elysia_cron_is_channel_disabled($channel);
    }
  }
}

function _elysia_cron_sort($a, $b) {
  if ((isset($a['weight']) ? $a['weight'] : 0) == (isset($b['weight']) ? $b['weight'] : 0)) {
    return strcmp((isset($a['key']) ? $a['key'] : ''), (isset($b['key']) ? $b['key'] : ''));
  }
  return (isset($a['weight']) ? $a['weight'] : 0) - (isset($b['weight']) ? $b['weight'] : 0);
}

/**
 * Prepare system for a cron execution.
 *
 * This should be called at the start of a cron execution:
 * prepare_run
 *   lock_env
 *    look for channel/jobs ready for execution and change internal states ...
 *   unlock_env
 *   before_execution
 *     .. execute channel/jobs ..
 *   after_execution
 * unprepare_run.
 */
function elysia_cron_prepare_run($manual_run, $start = TRUE) {
  static $original_user;

  if ($start) {
    // Allow execution to continue even if the request gets canceled.
    @ignore_user_abort(TRUE);

    // Try to allocate enough time to run all the hook_cron implementations.
    if (!ini_get('safe_mode') && _elysia_cron_function_available('set_time_limit')) {
      set_time_limit(variable_get('elysia_cron_time_limit', 240));
    }

    // Prevent session information from being saved while cron is running.
    drupal_save_session(FALSE);

    // Force the current user to anonymous to ensure consistent permissions on
    // cron runs (only if run by interface).
    if ($manual_run) {
      $original_user = $GLOBALS['user'];
      $GLOBALS['user'] = drupal_anonymous_user();
    }

  }
  else {
    if ($manual_run) {
      // Restore the user.
      $GLOBALS['user'] = $original_user;
      /*if (EC_DRUPAL_VERSION >= 7) {
        drupal_save_session(TRUE);
      }*/
    }
  }
}

/**
 * Call this after a cron execution, prepared with elysia_cron_prepare_run()
 *
 * @see: elysia_cron_prepare_run()
 */
function elysia_cron_unprepare_run($manual_run) {
  elysia_cron_prepare_run($manual_run, FALSE);
}

/**
 * Use this before checking and modifying environment variables.
 *
 * @see: elysia_cron_prepare_run()
 */
function elysia_cron_lock_env($channel = NULL) {
  $execute = TRUE;
  $semaphore_name = elysia_cron_build_semaphore_name($channel);

  if (!lock_acquire($semaphore_name, 240)) {
    elysia_cron_warning('Attempting to re-run cron while it is already running.');
    $execute = FALSE;
  }

  return $execute;
}

/**
 * Unlock system locked with elysia_cron_lock_env.
 *
 * @see: elysia_cron_prepare_run().
 */
function elysia_cron_unlock_env($channel = NULL) {
  $semaphore_name = elysia_cron_build_semaphore_name($channel);
  lock_release($semaphore_name);
}

/**
 * Return semaphore name by channel.
 *
 * @param string|null $channel
 *   Channel name or NULL if channel not set.
 *
 * @return string
 *   Semaphore name trimmed by 255 chars length.
 */
function elysia_cron_build_semaphore_name($channel) {
  $semaphore_name = 'elysia_cron_semaphore';
  if (isset($channel)) {
    $semaphore_name .= ':' . $channel;
  }

  return drupal_substr($semaphore_name, 0, 255);
}

/**
 * Public function to invoke a complete cron_run.
 *
 * @param bool $manual_run
 *   Consider launched by a user command
 *   (don't check for key/ip, protect current user...).
 * @param bool $ignore_disable
 *   Run the channel (and all it's jobs) even if disabled.
 * @param bool $ignore_time
 *   Run channel (and all it's jobs) job even if not ready.
 * @param bool $ignore_running
 *   Run the channel (and all it's jobs) even if already running.
 */
function elysia_cron_run($manual_run = FALSE, $ignore_disable = FALSE, $ignore_time = FALSE, $ignore_running = FALSE) {
  global $_elysia_cron_exit_phase;

  // If DISABLED block the execution.
  if (!$ignore_disable && variable_get('elysia_cron_disabled', FALSE)) {
    elysia_cron_debug('Cron globally disabled, skipping run');
    return;
  }

  if (!empty($_elysia_cron_exit_phase)) {
    // We on "poormanscron" mode,
    // not necessary to do checks for cron_key or host or permission.
  }
  elseif (!$manual_run) {
    // Check for CRON_KEY or ALLOWED_HOSTS.
    if (!drupal_is_cli()) {
      $cron_key = variable_get('cron_key', '');
      if ($cron_key && (empty($_GET['cron_key']) || $_GET['cron_key'] != $cron_key)) {
        elysia_cron_debug('Cron key mismatch, skipping run');
        return;
      }
      $allowed_hosts = variable_get('elysia_cron_allowed_hosts', FALSE);
      if ($allowed_hosts && !in_array(ip_address(), explode(',', $allowed_hosts))) {
        elysia_cron_debug('Cron ip address mismatch, skipping run');
        return;
      }
    }
  }
  elseif (!elysia_cron_access('execute elysia_cron')) {
    elysia_cron_debug('Access denied for cron launching');
    return;
  }

  elysia_cron_prepare_run($manual_run);

  _ec_variable_set('elysia_cron_last_run', time());
  _ec_variable_set('cron_last', time());

  if ($execute = elysia_cron_lock_env()) {
    elysia_cron_initialize();

    $available_channel = elysia_cron_run_available_channel($ignore_disable, $ignore_time, $ignore_running);
    if ($available_channel) {
      // There are jobs ready to be executed
      // elysia_cron_internal_execute_channel calls elysia_cron_unlock_env.
      elysia_cron_internal_execute_channel($available_channel['name'], $available_channel['jobs'], $ignore_running);
    }
    else {
      // No jobs should be executed, i must unlock cron semaphore.
      elysia_cron_unlock_env();
      elysia_cron_debug('No channels ready to be executed, skipping cron.');
    }
  }

  elysia_cron_unprepare_run($manual_run);

  return $execute;
}

/**
 * Public function to execute all jobs in a channel.
 *
 * @param bool $ignore_disable
 *   Run the channel (and all it's jobs) even if disabled.
 * @param bool $ignore_time
 *   Run channel (and all it's jobs) job even if not ready.
 * @param bool $ignore_running
 *   Run the channel (and all it's jobs) even if already running.
 */
function elysia_cron_run_channel($channel, $ignore_disable = FALSE, $ignore_time = FALSE, $ignore_running = FALSE) {
  global $_elysia_cron_settings_by_channel;

  // Always $manual_run.
  elysia_cron_prepare_run(TRUE);
  if ($execute = elysia_cron_lock_env($channel)) {
    elysia_cron_initialize();
    $jobs = FALSE;
    if (isset($_elysia_cron_settings_by_channel[$channel])) {
      if ($ignore_disable || empty($_elysia_cron_settings_by_channel[$channel]['#data']['disabled'])) {
        $jobs = elysia_cron_check_run_channel($channel, $ignore_disable, $ignore_time, $ignore_running);
        if ($jobs && count($jobs)) {
          // elysia_cron_internal_execute_channel calls elysia_cron_unlock_env.
          elysia_cron_internal_execute_channel($channel, $jobs, $ignore_running);
        }
        else {
          elysia_cron_debug('Channel already running or no jobs ready to be executed, skipping');
        }
      }
      else {
        elysia_cron_warning('Channel is disabled, skipping');
      }
    }
    else {
      elysia_cron_warning('Channel not found, skipping');
    }
    if (!$jobs) {
      // No jobs should be executed, i must unlock cron semaphore.
      elysia_cron_unlock_env();
    }
  }
  elysia_cron_unprepare_run(TRUE);

  return $execute;
}

/**
 * Public function to execute a single job.
 *
 * @param bool $ignore_disable
 *   Run the job even if disabled.
 * @param bool $ignore_time
 *   Run the job even if not ready.
 * @param bool $ignore_running
 *   Run the job even if already running.
 */
function elysia_cron_run_job($job, $ignore_disable = FALSE, $ignore_time = FALSE, $ignore_running = FALSE) {
  global $_cron_completed, $_cron_executing_job, $_elysia_cron_settings;

  elysia_cron_initialize();

  if (isset($_elysia_cron_settings[$job])) {
    if (elysia_cron_should_run($_elysia_cron_settings[$job], -1, $ignore_disable, $ignore_time)) {
      if ($ignore_running || !elysia_cron_check_run_job($job)) {
        $_cron_completed = FALSE;
        $_cron_executing_job = $job;

        // Register shutdown callback.
        register_shutdown_function('elysia_cron_run_job_cleanup');

        elysia_cron_internal_execute_job($job);
        $_cron_completed = TRUE;

        elysia_cron_message('Job executed');
      }
      else {
        elysia_cron_debug('Job is already running, skipping');
      }
    }
    else {
      elysia_cron_debug('Job is disabled or not ready to be executed, skipping');
    }
  }
  else {
    elysia_cron_warning('Job not found, skipping');
  }
}

function elysia_cron_run_job_cleanup() {
  global $_cron_completed, $_cron_executing_job;

  if ($_cron_completed) {
    return;
  }

  // See if the semaphore is still locked.
  if (elysia_cron_is_job_running($_cron_executing_job)) {
    elysia_cron_warning('Unexpected termination of cron job %job manually started, aborted.', array('%job' => $_cron_executing_job));

    elysia_cron_set_job_running($_cron_executing_job, 0);
  }
}

/**
 * Internal function to execute all jobs in a channel.
 *
 * Function elysia_cron_lock_env() must be called BEFORE calling this method.
 */
function elysia_cron_internal_execute_channel($channel, $jobs, $ignore_running = FALSE) {
  global $_elysia_cron_current_channel, $_cron_completed, $_cron_completed_time;

  elysia_cron_debug('Cron channel %channel run started.', array('%channel' => $channel));

  $_elysia_cron_current_channel = $channel;
  elysia_cron_set($_elysia_cron_current_channel, TRUE, array(
    'running' => time(),
    'last_run' => time(),
  ));

  // Register shutdown callback.
  register_shutdown_function('elysia_cron_internal_execute_channel_cleanup');

  // Now I can unlock cron semaphore.
  elysia_cron_unlock_env();

  foreach ($jobs as $job) {
    if ($ignore_running || !elysia_cron_check_run_job($job)) {
      elysia_cron_internal_execute_job($job);
    }
  }

  $_cron_completed = TRUE;
  $_cron_completed_time = time();

  // Cron is really completed after shutdown functions.
  register_shutdown_function('elysia_cron_internal_execute_channel_completed');
}

/**
 * Internal function to execute a single job.
 */
function elysia_cron_internal_execute_job($job) {
  global $_elysia_cron_settings;

  elysia_cron_debug('Cron job %job started.', array('%job' => $job));

  $time = time();
  elysia_cron_set($job, FALSE, array(
    'running' => $time,
    'last_run' => $time,
  ));

  try {
    if (!empty($_elysia_cron_settings[$job]['file'])) {
      $file_path = !empty($_elysia_cron_settings[$job]['file path']) ? $_elysia_cron_settings[$job]['file path'] : drupal_get_path('module', $_elysia_cron_settings[$job]['module']);
      $file_path .= DIRECTORY_SEPARATOR . $_elysia_cron_settings[$job]['file'];
      include_once $file_path;
    }

    if (!empty($_elysia_cron_settings[$job]['expression'])) {
      eval($_elysia_cron_settings[$job]['expression']);
    }
    elseif (!empty($_elysia_cron_settings[$job]['callback']) && is_callable($_elysia_cron_settings[$job]['callback'])) {
      call_user_func_array($_elysia_cron_settings[$job]['callback'], $_elysia_cron_settings[$job]['arguments']);
    }
    else {
      $function = $_elysia_cron_settings[$job]['module'] . '_cronapi';
      $arguments = array('execute', $job);

      if (is_callable($function)) {
        call_user_func_array($function, $arguments);
      }
      else {
        elysia_cron_error('Execution of ' . $job . ' failed, can\'t find function!', array(), TRUE);
      }
    }
  }
  catch (Exception $e) {
    watchdog_exception('cron', $e);
  }

  $stats = elysia_cron_get_job_stats($job);
  $time = time() - $time;
  elysia_cron_set_job_stats(
    $job,
    -1,
    $time,
    ($c = $stats['execution_count'] + 1),
    round((($stats['avg_execution_time'] * ($c - 1)) + $time) / $c, 2),
    $time > $stats['max_execution_time'] ? $time : -1,
    array('running' => 0)
  );

  elysia_cron_debug('Cron job %job ended in %time secs.', array('%job' => $job, '%time' => $time));
}

/**
 * Check if the channel is idle (not running, or stuck). If so set returns available jobs.
 *
 * @return array of jobs ready to be executed, or FALSE if channel is running
 */
function elysia_cron_check_run_channel($channel, $ignore_disable = FALSE, $ignore_time = FALSE, $ignore_running = FALSE) {
  global $_elysia_cron_settings_by_channel;

  $jobs = FALSE;
  $stuck_time = variable_get('elysia_cron_stuck_time', 3600);
  $sem = elysia_cron_is_channel_running($channel);
  if ($sem && (time() - $sem > $stuck_time)) {
    elysia_cron_set_channel_running($channel, 0);
    $last_job = elysia_cron_execute_aborted($channel);
    unset($sem);
    elysia_cron_error('Cron channel (%channel) has been running for more than an %stuck_time secs and is most likely stuck. Last job executed: %job', array('%channel' => $channel, '%stuck_time' => $stuck_time, '%job' => $last_job), TRUE);
  }
  if (($ignore_running || empty($sem)) && ($ignore_disable || !$_elysia_cron_settings_by_channel[$channel]['#data']['disabled'])) {
    $jobs = elysia_cron_active_jobs($channel, $ignore_disable, $ignore_time);
  }
  return $jobs;
}

function elysia_cron_check_run_job($job) {
  $job_running = FALSE;
  if (elysia_cron_is_job_running($job)) {
    if (time() - elysia_cron_get_job_last_run($job, 0) > variable_get('elysia_cron_stuck_time', 3600)) {
      elysia_cron_warning('Job %job is already running, but is probably stuck, so i consider it as terminated', array('%job' => $job));
    }
    else {
      elysia_cron_warning('Job %job is already running', array('%job' => $job));
      $job_running = TRUE;
    }
  }
  return $job_running;
}

/**
 * Find an idle channel (not running, or stuck). If found one, set it as running and returns available jobs.
 *
 * @return if found returns array { 'name' => name of channel, 'jobs' => array of active jobs }, else return FALSE
 */
function elysia_cron_run_available_channel($ignore_disable = FALSE, $ignore_time = FALSE, $ignore_running = FALSE) {
  global $_elysia_cron_settings_by_channel;

  $channels = array_keys($_elysia_cron_settings_by_channel);
  $channel = elysia_cron_last_channel();
  $i = array_search($channel, $channels);
  if ($i === FALSE) {
    $i = -1;
  }
  $k = 0;
  $jobs = FALSE;
  for ($j = ($i + 1) % count($channels); $k < count($channels); $j = ($j + 1) % count($channels)) {
    $jobs = elysia_cron_check_run_channel($channels[$j], $ignore_disable, $ignore_time, $ignore_running);
    if ($jobs && count($jobs)) {
      break;
    }
    $k++;
  }
  if ($jobs) {
    elysia_cron_set_last_channel($channels[$j]);
  }
  return $jobs ? array('name' => $channels[$j], 'jobs' => $jobs) : FALSE;
}

function elysia_cron_execute_aborted($channel) {
  global $_elysia_cron_settings_by_channel;

  $last_job = '';
  foreach ($_elysia_cron_settings_by_channel[$channel] as $job => $conf) {
    if ($job != '#data') {
      if (elysia_cron_is_job_running($job)) {
        $last_job .= ' ' . $job;
        elysia_cron_set_job_running($job, 0);
      }
    }
  }

  // In case the last function to run is longer than 128 chars, we cap the
  // length prior to placing in the database.
  $last_job = trim($last_job);
  if (strlen($last_job) > 128) {
    $last_job = substr($last_job, 0, 128);
  }

  elysia_cron_set($channel, TRUE, array(
    'running' => 0, //time(),.
    'last_aborted' => 1,
    'abort_count' => elysia_cron_get_channel_abort_count($channel) + 1,
    'last_abort_function' => $last_job,
  ));

  return $last_job;
}

/**
 * Shutdown function for cron cleanup.
 *
 * Used for unexpected termination of code.
 */
function elysia_cron_internal_execute_channel_cleanup() {
  global $_elysia_cron_settings, $_elysia_cron_current_channel, $_cron_completed, $_cron_completed_time;

  if ($_cron_completed) {
    return;
  }

  // See if the semaphore is still locked.
  if (elysia_cron_is_channel_running($_elysia_cron_current_channel)) {
    $last_job = elysia_cron_execute_aborted($_elysia_cron_current_channel);
    elysia_cron_warning('Unexpected termination of cron channel %channel, aborted. Last job executed: %job', array('%channel' => $_elysia_cron_current_channel, '%job' => $last_job));
  }
}

/**
 * Successful termination (after all shutdown hooks invoked by cron functions).
 */
function elysia_cron_internal_execute_channel_completed() {
  global $_elysia_cron_current_channel, $_cron_completed_time;

  // Record cron time.
  _ec_variable_set('cron_last', time());

  elysia_cron_debug('Cron channel %channel run completed.', array('%channel' => $_elysia_cron_current_channel));

  $stats = elysia_cron_get_channel_stats($_elysia_cron_current_channel);
  $time = time() - $stats['last_run'];

  $exec_count = $stats['execution_count'] + 1;
  $channel_stats_data = array(
    'last_execution_time' => $time,
    'execution_count' => $exec_count,
    'avg_execution_time' => round((($stats['avg_execution_time'] * ($exec_count - 1)) + $time) / $exec_count, 2),
    'max_execution_time' => $time > $stats['max_execution_time'] ? $time : $stats['max_execution_time'],
    'last_shutdown_time' => time() - $_cron_completed_time,
    'last_aborted' => 0,
    'running' => 0,
  );

  elysia_cron_set_channel_stats($_elysia_cron_current_channel, $channel_stats_data);
}

/**
 * Get all jobs that needs to be executed in a channel
 */
function elysia_cron_active_jobs($channel, $ignore_disable = FALSE, $ignore_time = FALSE) {
  global $_elysia_cron_settings_by_channel;

  $jobs = array();
  foreach ($_elysia_cron_settings_by_channel[$channel] as $job => $conf) {
    if ($job != '#data') {
      if (elysia_cron_should_run($conf, -1, $ignore_disable, $ignore_time)) {
        $jobs[] = $job;
      }
    }
  }
  return $jobs;
}

/**
 * Check if cron is currently running.
 * (Not used by elysia_cron, can be used by external modules)
 */
function elysia_cron_is_running() {
  global $_elysia_cron_settings_by_channel;
  elysia_cron_initialize();

  $running = array();
  foreach ($_elysia_cron_settings_by_channel as $channel => $data) {
    if (elysia_cron_is_channel_running($channel)) {
      $running[] = $channel;
    }
  }

  return $running;
}

function elysia_cron_job_exists($job) {
  global $_elysia_cron_settings;
  return isset($_elysia_cron_settings[$job]);
}

function elysia_cron_channel_exists($channel) {
  global $_elysia_cron_settings_by_channel;
  return isset($_elysia_cron_settings_by_channel[$channel]);
}

/**
 * Obtain job description (translated)
 */
function elysia_cron_description($job) {
  global $_elysia_cron_settings;

  if (!empty($_elysia_cron_settings[$job]['description'])) {
    $desc = $_elysia_cron_settings[$job]['description'];
  }
  else {
    $desc = theme('elysia_cron_description', array('job' => $job));
  }

  return t($desc);
}

/*******************************************************************************
 * THEMING
 ******************************************************************************/

/**
 * Implementation of hook_theme().
 */
function elysia_cron_theme() {
  return array(
    'elysia_cron_description' => array(
      'variables' => array('job' => NULL),
    ),
    'elysia_cron_settings_form' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * You can theme this function to provide your (untranslated) descriptions for cron functions, if they do not provide one.
 */
function theme_elysia_cron_description($variables) {
  switch ($variables['job']) {
    case 'search_cron':
      return 'Update search database index';

    case 'activitystream_cron':
      return 'Fetch RSS feeds and web calls for activitystream';

    case 'mailhandler_cron':
      return 'Fetch POP3/IMAP accounts managed by MailHandler';

    case 'watchdog_cron':
      return 'Remove expired log messages and flood control events';

    case 'filter_cron':
      return 'Expire outdated filter cache entries';

    case 'node_cron':
      return 'History table cleanup';

    case 'system_cron':
      return 'Remove older rows from flood and batch table. Remove old temporary files.';

    case 'aggregation_cron':
      return 'Fetch RSS feeds for aggregation module';

    case 'amazon_cron':
      return 'Refresh Amazon products';

    case 'image_cron':
      return 'Deletes old temp images';

    case 'persistent_login_cron':
      return 'Expire persistent login';

    case 'trackback_cron':
      return 'Process trackback ping queue';

    case 'update_status_cron':
      return 'Checks for drupal module updates (Note: own frequency check ignore cron rules)';

    case 'user_karma_cron':
      return 'User karma expiration / rebuild (Note: own frequency check ignore cron rules)';

    case 'votingapi_cron':
      return 'Update votes (if not configured for immediate calculation)';

    case 'statistics_cron':
      return 'Reset day counts / Clean expired access logs';

    case 'googleanalytics_cron':
      return 'Delete cached version of ga.js/urchin.js.';

    case 'xmlsitemap_cron':
      return 'XML sitemap ping.';

    case 'xmlsitemap_node_cron':
      return 'Update XML sitemap with new nodes';

    case 'xmlsitemap_term_cron':
      return 'Update XML sitemap with new terms';

    case 'lm_paypal_cron':
      return 'Remove old IPN records';

    case 'user_import_cron':
      return 'Continue partial imports';

    case 'dblog_cron':
      return 'Remove expired log messages and flood control events';

    case 'field_cron':
      return 'Purges some deleted Field API data, if any exists';

    case 'trigger_cron':
      return 'Triggers cron actions';

    case 'update_cron':
      return 'Checks for available updates of Drupal core, contributed modules and themes';

    case 'search_api_cron':
      return 'Will index items for each enabled index.';

    case 'redirect_cron':
      return 'Purge inactive self-managed redirects from the database.';

    case 'ctools_cron':
      return 'Clean up old caches';

    case 'l10n_update_cron':
      return 'Check one project/language at a time, download and import if update available';

    default:
      return '-';
  }
}

/*******************************************************************************
 * PING SUPPORT
 ******************************************************************************/

/**
 * Page callback for ping page.  Throws 404 if cron hasn't been called within configured time period.
 */
function elysia_cron_ping_page() {
  $last_run = _ec_variable_get('elysia_cron_last_run', 0);
  $diff = time() - $last_run;
  $max_interval = variable_get('elysia_cron_alert_interval', 60) * 60;

  if ($diff > $max_interval) {
    return drupal_not_found();
  }
  else {
    $aoutput = array();
    $aoutput[] = array(
      '#type' => 'markup',
      '#markup' => t('Cron has been called within maximum lapse time.'),
    );
    return $aoutput;
  }
}

/*******************************************************************************
 * DRUPAL QUEUE SUPPORT
 * ONLY FOR D7
 ******************************************************************************/

function elysia_cron_cronapi($op, $job = FALSE) {
  $items = array();

  $queues = module_invoke_all('cron_queue_info');
  drupal_alter('cron_queue_info', $queues);

  foreach ($queues as $queue_name => $info) {
    if (!empty($info['skip on cron'])) {
      // Do not run if queue wants to skip.
      continue;
    }

    // Make sure every queue exists. There is no harm in trying to recreate an
    // existing queue.
    $queue = DrupalQueue::get($queue_name);
    $queue->createQueue();

    // Some queue backends may have performance issues with counting items.
    if (variable_get('elysia_cron_queue_show_count', TRUE)) {
      $queue_description = $queue_name . ' queue processing (Items count: <strong>' . $queue->numberOfItems() . '</strong>, worker max duration: <strong>' . (isset($info['time']) ? $info['time'] . 's' : t('unspecified') . ' (15s)') . '</strong>)';
    }
    else {
      $queue_description = $queue_name . ' queue processing (Worker max duration: <strong>' . (isset($info['time']) ? $info['time'] . 's' : t('unspecified') . ' (15s)') . '</strong>)';
    }

    $items['queue_' . $queue_name] = array(
      'description' => $queue_description,
      'rule' => variable_get('elysia_cron_queue_default_rule', FALSE),
      'weight' => variable_get('elysia_cron_queue_default_weight', 100),
      'callback' => 'elysia_cron_queue_exec',
      'arguments' => array($queue_name, $info),
    );
  }

  return $items;
}

function elysia_cron_queue_exec($queue_name, $info) {
  $function = $info['worker callback'];
  $end = time() + (isset($info['time']) ? $info['time'] : 15);
  $queue = DrupalQueue::get($queue_name);
  while (time() < $end && ($item = $queue->claimItem())) {
    try {
      $function($item->data);
      $queue->deleteItem($item);
    }
    catch (Exception $e) {
      // In case of exception log it and leave the item in the queue
      // to be processed again later.
      watchdog_exception('cron', $e);
    }
  }
}

/*******************************************************************************
 * ADMIN_MENU SUPPORT
 ******************************************************************************/

// @todo Deve gestire hook_admin_menu_map, vedi hook_admin_menu.php e admin_menu.map.inc
/**
 * Implements hook_admin_menu().
 *
 * @param array &$deleted
 *   Array of links under admin/* that were removed by
 *   admin_menu_adjust_items(). If one of these links is added back,
 *   it should be removed from the array.
 */
function elysia_cron_admin_menu(&$deleted) {
  $links = array();

  elysia_cron_initialize();
  global $_elysia_cron_settings_by_channel;

  // Add link to manually run cron.
  $links[] = array(
    'title' => 'Elysia cron manual',
    'path' => 'admin/config/system/cron',
    'weight' => 50,
    'has_children' => FALSE,
    'parent_path' => '<front>',
  );

  foreach ($_elysia_cron_settings_by_channel as $channel => $data) {
    foreach ($data as $job => $conf) {
      if ($job != '#data') {
        $links[] = array(
          'title' => "Elysia cron run manual !title",
          'path' => 'admin/config/system/cron/execute/' . $job,
          'weight' => -50,
          'query' => 'destination',
          'parent_path' => 'admin/config/system/cron',
          'options' => array('t' => array('!title' => $conf['module'])),
        );
      }
    }
  }

  return $links;
}

/**
 * Check if function available to use.
 *
 * Some native php function can be disabled by configuration,
 * to avoid a lot of notices we check availability of such functions.
 *
 * @param string $func
 *   Function to check.
 *
 * @return bool
 *   TRUE if function available for use, FALSE otherwise.
 */
function _elysia_cron_function_available($func) {
  $disabled = explode(',', ini_get('disable_functions'));
  return !in_array($func, $disabled);
}

/**
 * Get list of columns from elysia_cron table.
 *
 * @return array
 *   List of columns.
 */
function _elysia_cron_columns() {
  return array(
    'name',
    'disable',
    'rule',
    'weight',
    'context',
    'running',
    'last_run',
    'last_aborted',
    'abort_count',
    'last_abort_function',
    'last_execution_time',
    'execution_count',
    'avg_execution_time',
    'max_execution_time',
    'last_shutdown_time',
  );
}

/**
 * Get list of predefined cron rules.
 *
 * @return array
 *   List of predefined rules.
 */
function _elysia_cron_default_rules() {
  return array(
    '*/15 * * * *' => 'Every 15 minutes',
    '*/30 * * * *' => 'Every 30 minutes',
    '0 * * * *' => 'Every hour',
    '0 */6 * * *' => 'Every 6 hours',
    '4 0 * * *' => 'Once a day',
    '4 0 * * 0' => 'Once a week',
    '4 0 1 * *' => 'Once a month',
  );
}
